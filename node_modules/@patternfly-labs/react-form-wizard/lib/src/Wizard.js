import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Alert, Button, DescriptionList, Drawer, DrawerContent, DrawerContentBody, DrawerPanelContent, PageSection, PageSectionTypes, Split, SplitItem, Tab, Tabs, TabTitleText, } from '@patternfly/react-core';
import { ExclamationCircleIcon } from '@patternfly/react-icons';
import Handlebars from 'handlebars';
import { Children, Fragment, isValidElement, useCallback, useEffect, useLayoutEffect, useMemo, useState, } from 'react';
import { EditMode } from '.';
import { YamlEditor, YamlToObject } from './components/YamlEditor';
import { DataContext, useData } from './contexts/DataContext';
import { DisplayMode, DisplayModeContext } from './contexts/DisplayModeContext';
import { EditModeContext } from './contexts/EditModeContext';
import { HasInputsProvider } from './contexts/HasInputsProvider';
import { ItemContext, useItem } from './contexts/ItemContext';
import { ShowValidationProvider, useSetShowValidation, useShowValidation } from './contexts/ShowValidationProvider';
import { StepHasInputsProvider, useStepHasInputs } from './contexts/StepHasInputsProvider';
import { StepValidationProvider, useStepHasValidationError } from './contexts/StepValidationProvider';
import { useHasValidationError, ValidationProvider } from './contexts/ValidationProvider';
import { useID } from './inputs/Input';
import { Step } from './Step';
Handlebars.registerHelper('if_eq', function (arg1, arg2, options) {
    return arg1 == arg2 ? options.fn(this) : options.inverse(this);
});
Handlebars.registerHelper('if_ne', function (arg1, arg2, options) {
    return arg1 !== arg2 ? options.fn(this) : options.inverse(this);
});
function getSteps(children) {
    const childArray = Children.toArray(children);
    let steps = childArray.filter((child) => isValidElement(child) && child.type === Step);
    if (steps.length === 0) {
        if (childArray.length === 1) {
            const child = childArray[0];
            if (isValidElement(child)) {
                steps = getSteps(child.props.children);
            }
        }
    }
    return steps;
}
export function Wizard(props) {
    const [data, setData] = useState(props.defaultData ? JSON.parse(JSON.stringify(props.defaultData)) : {});
    const update = useCallback((newData) => setData((data) => JSON.parse(JSON.stringify(newData ?? data))), []);
    const [drawerExpanded, setDrawerExpanded] = useState(false);
    useEffect(() => {
        if (props.showYaml !== undefined) {
            setDrawerExpanded(props.showYaml);
        }
    }, [props.showYaml]);
    const displayMode = DisplayMode.Wizard;
    const [template] = useState(() => (props.template ? Handlebars.compile(props.template) : undefined));
    const [template2] = useState(() => (props.yamlToDataTemplate ? Handlebars.compile(props.yamlToDataTemplate) : undefined));
    const isYamlArray = useMemo(() => Array.isArray(props.defaultData), [props.defaultData]);
    return (_jsx(EditModeContext.Provider, { value: props.editMode === undefined ? EditMode.Create : props.editMode, children: _jsx(StepHasInputsProvider, { children: _jsx(StepValidationProvider, { children: _jsx(DisplayModeContext.Provider, { value: displayMode, children: _jsx(DataContext.Provider, { value: { update }, children: _jsx(ItemContext.Provider, { value: data, children: _jsx(ShowValidationProvider, { children: _jsx(ValidationProvider, { children: _jsx(Drawer, { isExpanded: drawerExpanded, isInline: true, children: _jsx(DrawerContent, { panelContent: _jsx(WizardPageDrawer, { data: data, template: template, template2: template2, templateString: props.template, isYamlArray: isYamlArray }, void 0), children: _jsx(DrawerContentBody, { children: _jsx(PageSection, { variant: "light", style: { height: '100%' }, type: displayMode === DisplayMode.Wizard
                                                        ? PageSectionTypes.wizard
                                                        : PageSectionTypes.default, isWidthLimited: true, children: _jsx(ItemContext.Provider, { value: data, children: _jsx(WizardInternal, { onSubmit: props.onSubmit, onCancel: props.onCancel, hasButtons: props.hasButtons, template: template, isYamlArray: isYamlArray, children: props.children }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0));
}
function WizardInternal(props) {
    const steps = getSteps(props.children);
    if (props.hasButtons !== false) {
        steps.push(_jsx(Step, { label: "Review", id: "review-step", children: _jsx(DescriptionList, { isHorizontal: true, isCompact: true, style: { paddingLeft: 16, paddingBottom: 16, paddingRight: 16 }, children: _jsx(DisplayModeContext.Provider, { value: DisplayMode.Details, children: props.children }, void 0) }, void 0) }, void 0));
    }
    const [activeIndex, setActiveIndex] = useState(0);
    const next = useCallback(() => setActiveIndex((activeIndex) => activeIndex + 1), []);
    const back = useCallback(() => setActiveIndex((activeIndex) => activeIndex - 1), []);
    const setActiveStep = (step) => setActiveIndex(steps.indexOf(step));
    let activeStep = steps[activeIndex];
    if (!activeStep)
        activeStep = steps[0];
    const setShowValidation = useSetShowValidation();
    useLayoutEffect(() => {
        if (activeStep.props.id === 'review-step') {
            setShowValidation(true);
        }
    }, [activeStep, setShowValidation]);
    return (_jsx("div", { className: "pf-c-wizard", children: steps?.map((step) => {
            if (step !== activeStep)
                return (_jsx(HasInputsProvider, { children: _jsx(ShowValidationProvider, { children: _jsx(ValidationProvider, { children: _jsx("div", { style: { display: 'none' }, children: step }, void 0) }, void 0) }, void 0) }, step.props.id));
            if (step.props.id === 'review-step') {
                return (_jsx(HasInputsProvider, { children: _jsx(WizardActiveStep, { activeStep: activeStep, setActiveStep: setActiveStep, steps: steps, next: next, back: back, onSubmit: props.onSubmit, onCancel: props.onCancel, hasButtons: props.hasButtons, template: props.template, isYamlArray: props.isYamlArray }, void 0) }, step.props.id));
            }
            return (_jsx(HasInputsProvider, { children: _jsx(ShowValidationProvider, { children: _jsx(ValidationProvider, { children: _jsx(WizardActiveStep, { activeStep: activeStep, setActiveStep: setActiveStep, steps: steps, next: next, back: back, onSubmit: props.onSubmit, onCancel: props.onCancel, hasButtons: props.hasButtons, isYamlArray: props.isYamlArray }, void 0) }, void 0) }, void 0) }, step.props.id));
        }) }, void 0));
}
export function WizardActiveStep(props) {
    const [submitting, setSubmitting] = useState(false);
    const [submitError, setSubmitError] = useState('');
    const { onSubmit } = props;
    const onSubmit2 = useCallback(async (data) => {
        setSubmitError('');
        setSubmitting(true);
        try {
            await onSubmit(data);
        }
        catch (err) {
            if (err instanceof Error) {
                setSubmitError(err.message);
                return err.message;
            }
            else {
                setSubmitError('Unknown error');
                return 'Unknown error';
            }
        }
        finally {
            setSubmitting(false);
        }
        return undefined;
    }, [onSubmit]);
    const hasValidationError = useHasValidationError();
    const showValidation = useShowValidation();
    const setShowValidation = useSetShowValidation();
    const id = useID(props.activeStep.props);
    const item = useItem();
    return (_jsxs("div", { className: "pf-c-wizard__outer-wrap", id: id, children: [_jsxs("div", { className: "pf-c-wizard__inner-wrap", children: [_jsx("nav", { className: "pf-c-wizard__nav", "aria-label": "Steps", children: _jsx("ol", { className: "pf-c-wizard__nav-list", children: props.steps?.map((step) => (_jsx(StepNavItem, { step: step, activeStep: props.activeStep, setActiveStep: props.setActiveStep, isDisabled: submitting }, step.props.label))) }, void 0) }, void 0), _jsx("main", { className: "pf-c-wizard__main", children: _jsx("div", { className: "pf-c-wizard__main-body", children: _jsx("form", { noValidate: true, className: "pf-c-form", children: props.activeStep }, void 0) }, void 0) }, void 0)] }, void 0), hasValidationError && showValidation && _jsx(Alert, { title: "Please fix validation errors", isInline: true, variant: "danger" }, void 0), submitError && _jsx(Alert, { title: submitError, isInline: true, variant: "danger" }, void 0), props.hasButtons !== false && (_jsxs("footer", { className: "pf-c-wizard__footer", children: [props.activeStep === props.steps[props.steps.length - 1] ? (_jsx(Button, { variant: "primary", isDisabled: (hasValidationError && showValidation) || submitting, type: "submit", onClick: () => {
                            setShowValidation(true);
                            if (props.template) {
                                void onSubmit2(YamlToObject(props.template(item), props.isYamlArray));
                            }
                            else {
                                void onSubmit2(item);
                            }
                        }, isLoading: submitting, children: submitting ? 'Submitting' : 'Submit' }, void 0)) : (_jsx(Button, { variant: "primary", isDisabled: (hasValidationError && showValidation) || submitting, type: "submit", onClick: () => {
                            setShowValidation(true);
                            if (!hasValidationError) {
                                props.next();
                            }
                        }, children: "Next" }, void 0)), _jsx(Button, { variant: "secondary", onClick: props.back, isDisabled: props.activeStep === props.steps?.[0] || submitting, children: "Back" }, void 0), _jsx("div", { className: "pf-c-wizard__footer-cancel", children: _jsx(Button, { variant: "link", onClick: props.onCancel, children: "Cancel" }, void 0) }, void 0)] }, void 0))] }, void 0));
}
function StepNavItem(props) {
    let classname = 'pf-c-wizard__nav-link';
    if (props.activeStep === props.step) {
        classname += ' pf-m-current';
    }
    const stepHasValidationError = useStepHasValidationError();
    const stepHasInputs = useStepHasInputs();
    if (!stepHasInputs[props.step.props.id]) {
        return _jsx(Fragment, {}, void 0);
    }
    return (_jsx("li", { className: "pf-c-wizard__nav-item", children: _jsx("button", { id: `${props.step.props.id}-button`, className: classname, onClick: () => {
                props.setActiveStep(props.step);
            }, disabled: props.isDisabled, children: _jsxs(Split, { children: [_jsx(SplitItem, { isFilled: true, children: props.step.props.label }, void 0), props.step.props.id !== 'review-step' && stepHasValidationError[props.step.props.id] && (_jsx(SplitItem, { children: _jsx(ExclamationCircleIcon, { color: "var(--pf-global--danger-color--100)" }, void 0) }, void 0))] }, void 0) }, void 0) }, props.step.props.id));
}
function WizardPageDrawer(props) {
    const [activeKey, setActiveKey] = useState(0);
    const { update } = useData();
    const devMode = process.env.NODE_ENV === 'development';
    return (_jsx(DrawerPanelContent, { isResizable: true, defaultSize: "800px", style: { backgroundColor: 'rgb(21, 21, 21)' }, children: props.template && devMode ? (_jsx("div", { style: { height: '100%' }, children: _jsxs(Tabs, { activeKey: activeKey, onSelect: (_event, tabIndex) => setActiveKey(tabIndex), isBox: true, variant: "light300", isFilled: true, style: { backgroundColor: 'white' }, children: [_jsx(Tab, { eventKey: 0, title: _jsx(TabTitleText, { children: "Yaml" }, void 0), children: _jsx(YamlEditor, { data: props.template ? YamlToObject(props.template(props.data), props.isYamlArray) : props.data, setData: (data) => {
                                let newData = data;
                                if (props.template2)
                                    newData = YamlToObject(props.template2(data), props.isYamlArray);
                                update(newData);
                            }, isYamlArray: props.isYamlArray }, void 0) }, void 0), _jsx(Tab, { eventKey: 2, title: _jsx(TabTitleText, { children: "Data" }, void 0), children: _jsx(YamlEditor, { data: props.data, isYamlArray: props.isYamlArray }, void 0) }, void 0)] }, void 0) }, void 0)) : (_jsx(YamlEditor, { data: props.template ? YamlToObject(props.template(props.data), props.isYamlArray) : props.data, setData: (data) => {
                let newData = data;
                if (props.template2)
                    newData = YamlToObject(props.template2(data), props.isYamlArray);
                update(newData);
            }, isYamlArray: props.isYamlArray }, void 0)) }, void 0));
}
//# sourceMappingURL=Wizard.js.map
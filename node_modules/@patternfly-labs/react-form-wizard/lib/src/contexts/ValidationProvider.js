import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useLayoutEffect, useState } from 'react';
const SetHasValidationErrorContext = createContext(() => null);
export const useSetHasValidationError = () => useContext(SetHasValidationErrorContext);
export const HasValidationErrorContext = createContext(true);
export const useHasValidationError = () => useContext(HasValidationErrorContext);
const ValidateContext = createContext(() => null);
export const useValidate = () => useContext(ValidateContext);
export function ValidationProvider(props) {
    const [hasValidationError, setHasValidationErrorState] = useState(false);
    const [setHasValidationError, setHasValidationErrorFunction] = useState(() => () => setHasValidationErrorState(true));
    const validate = useCallback(() => {
        setHasValidationErrorState(false);
        setHasValidationErrorFunction(() => () => setHasValidationErrorState(true));
    }, []);
    useLayoutEffect(() => validate(), [validate]);
    const parentValidate = useContext(ValidateContext);
    useLayoutEffect(() => {
        if (!hasValidationError)
            parentValidate?.();
    }, [parentValidate, hasValidationError]);
    useLayoutEffect(() => () => {
        if (parentValidate)
            parentValidate();
    }, [parentValidate]);
    const parentSetHasValidationError = useContext(SetHasValidationErrorContext);
    useLayoutEffect(() => {
        if (hasValidationError)
            parentSetHasValidationError?.();
    }, [parentSetHasValidationError, hasValidationError]);
    return (_jsx(ValidateContext.Provider, { value: validate, children: _jsx(SetHasValidationErrorContext.Provider, { value: setHasValidationError, children: _jsx(HasValidationErrorContext.Provider, { value: hasValidationError, children: props.children }, void 0) }, void 0) }, void 0));
}
//# sourceMappingURL=ValidationProvider.js.map
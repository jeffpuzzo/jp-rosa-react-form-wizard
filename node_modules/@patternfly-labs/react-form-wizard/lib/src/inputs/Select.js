import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Chip, ChipGroup, DescriptionListDescription, DescriptionListGroup, DescriptionListTerm, Select as PfSelect, SelectOption, SelectVariant, } from '@patternfly/react-core';
import get from 'get-value';
import { Fragment, useCallback, useMemo, useState } from 'react';
import { DisplayMode } from '../contexts/DisplayModeContext';
import { lowercaseFirst, useInput } from './Input';
import { InputLabel } from './InputLabel';
import './Select.css';
export function Select(props) {
    return _jsx(SelectBase, { ...props, variant: "single" }, void 0);
}
function SelectBase(props) {
    const { displayMode: mode, value, setValue, validated, hidden, id, disabled } = useInput(props);
    const placeholder = props.placeholder ?? `Select the ${lowercaseFirst(props.label)}`;
    const keyPath = props.keyPath ?? props.path;
    const isCreatable = props.isCreatable;
    const [open, setOpen] = useState(false);
    const selectOptions = useMemo(() => {
        switch (props.variant) {
            case 'single':
                return props.options?.map((option) => {
                    let id;
                    let label;
                    let value;
                    let keyedValue;
                    let toString;
                    if (typeof option === 'string' || typeof option === 'number') {
                        id = option.toString();
                        label = option.toString();
                        value = option;
                        keyedValue = option;
                        toString = () => option.toString();
                    }
                    else {
                        id = option.id ?? option.label;
                        label = option.label;
                        if (!keyPath)
                            throw new Error('keyPath is required');
                        value = option.value;
                        keyedValue = get(value, keyPath);
                        switch (typeof keyedValue) {
                            case 'string':
                            case 'number':
                                break;
                            default:
                                throw new Error('keyedValue is not a string or number');
                        }
                        toString = () => {
                            return option.label;
                        };
                    }
                    const compareTo = (compareTo) => compareTo === keyedValue;
                    return { id, label, value, keyedValue, toString, compareTo };
                });
        }
    }, [props, keyPath]);
    const keyedValue = useMemo(() => {
        if (typeof value === 'undefined')
            return '';
        if (typeof value === 'string')
            return value;
        if (typeof value === 'number')
            return value;
        if (Array.isArray(value)) {
            return value.map((value) => {
                if (typeof value === 'string')
                    return value;
                if (typeof value === 'number')
                    return value;
                if (!keyPath)
                    throw new Error();
                const valueKey = get(value, keyPath);
                if (typeof valueKey === 'string')
                    return valueKey;
                if (typeof valueKey === 'number')
                    return valueKey;
                throw new Error();
            });
        }
        if (!keyPath)
            throw new Error();
        const valueKey = get(value, keyPath);
        if (typeof valueKey === 'string')
            return valueKey;
        if (typeof valueKey === 'number')
            return valueKey;
        throw new Error();
    }, [value, keyPath]);
    const selections = useMemo(() => {
        if (Array.isArray(keyedValue)) {
            return selectOptions?.filter((selectOption) => keyedValue.find((keyedValue) => keyedValue === selectOption.keyedValue) !== undefined);
        }
        else {
            return selectOptions?.find((selectOption) => keyedValue === selectOption.keyedValue);
        }
    }, [keyedValue, selectOptions]);
    const onSelect = useCallback((_, selectOptionObject) => {
        switch (props.variant) {
            case 'single':
                if (isCreatable && typeof selectOptionObject === 'string') {
                    setValue(selectOptionObject);
                }
                else {
                    setValue(selectOptionObject.value);
                }
                setOpen(false);
                break;
        }
    }, [isCreatable, props.variant, setValue]);
    const onClear = useCallback(() => {
    }, []);
    const onFilter = useCallback((_, value) => {
        if (selectOptions)
            return selectOptions
                .filter((option) => option.label.toLowerCase().includes(value.toLowerCase()))
                .map((option) => (_jsx(SelectOption, { id: option.id, value: option, description: option.description, isDisabled: option.disabled, children: option.toString() }, option.id)));
        return [];
    }, [selectOptions]);
    const variant = useMemo(() => {
        switch (props.variant) {
            case 'single':
                return SelectVariant.single;
        }
    }, [props.variant]);
    if (hidden)
        return _jsx(Fragment, {}, void 0);
    if (mode === DisplayMode.Details) {
        if (!value)
            return _jsx(Fragment, {}, void 0);
        return (_jsxs(DescriptionListGroup, { children: [_jsx(DescriptionListTerm, { children: props.label }, void 0), _jsx(DescriptionListDescription, { id: id, children: value }, void 0)] }, void 0));
    }
    return (_jsx("div", { id: id, children: _jsx(InputLabel, { ...props, children: _jsx(PfSelect, { isDisabled: disabled || !selectOptions, variant: variant, isOpen: open, onToggle: setOpen, selections: selections, onSelect: onSelect, onClear: props.required ? undefined : onClear, isCreatable: isCreatable, onCreateOption: (value) => props.onCreate?.(value), validated: validated, hasInlineFilter: true, onFilter: onFilter, footer: props.footer, placeholderText: Array.isArray(selections) ? (selections.length === 0 ? (placeholder) : (_jsx(ChipGroup, { style: { marginTop: -8, marginBottom: -8 }, numChips: 9999, children: selections.map((selection) => (_jsx(Chip, { isReadOnly: true, children: selection.label }, selection.id))) }, void 0))) : (placeholder), children: selectOptions?.map((option) => (_jsx(SelectOption, { id: option.id, value: option, description: option.description, isDisabled: option.disabled, children: option.toString() }, option.id))) }, void 0) }, void 0) }, void 0));
}
//# sourceMappingURL=Select.js.map
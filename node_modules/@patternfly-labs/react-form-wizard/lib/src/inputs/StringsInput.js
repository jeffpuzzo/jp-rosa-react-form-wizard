import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Button, DescriptionListDescription, DescriptionListGroup, DescriptionListTerm, Divider, InputGroup, TextInput as PFTextInput, } from '@patternfly/react-core';
import { PlusIcon, TrashIcon } from '@patternfly/react-icons';
import { Fragment } from 'react';
import { TextInput } from '..';
import { DisplayMode } from '../contexts/DisplayModeContext';
import { useInput } from './Input';
import { InputLabel } from './InputLabel';
export function StringsInput(props) {
    const { displayMode: mode, value, setValue, id, hidden } = useInput(props);
    let values = value;
    if (!values)
        values = [];
    const onNewKey = () => {
        values.push('');
        setValue(values);
    };
    const onDeleteKey = (index) => {
        values.splice(index, 1);
        setValue(values);
    };
    if (hidden) {
        return _jsx(Fragment, {}, void 0);
    }
    if (mode === DisplayMode.Details) {
        if (!values.length)
            return _jsx(Fragment, {}, void 0);
        return (_jsxs(DescriptionListGroup, { children: [_jsx(DescriptionListTerm, { children: props.label }, void 0), _jsx(DescriptionListDescription, { id: id, children: _jsx("div", { style: { display: 'flex', flexDirection: 'column', rowGap: 8 }, children: values.map((value, index) => {
                            if (!value)
                                return _jsx(Fragment, {}, index);
                            return _jsx("div", { children: value }, index);
                        }) }, void 0) }, void 0)] }, void 0));
    }
    return (_jsx(InputLabel, { ...props, id: id, children: _jsxs("div", { id: id, style: { display: 'flex', flexDirection: 'column', rowGap: values.length ? 8 : 4 }, children: [_jsx("div", { style: { display: 'flex', flexDirection: 'column', rowGap: 8 }, children: values.map((_, index) => {
                        return (_jsxs(InputGroup, { children: [_jsx(TextInput, { id: `${id}-${index + 1}`, path: props.path + '.' + index.toString(), required: true, disablePaste: true }, void 0), _jsx(Button, { variant: "plain", isDisabled: props.required === true && values.length === 1, "aria-label": "Remove item", onClick: () => onDeleteKey(index), style: { alignSelf: 'start' }, children: _jsx(TrashIcon, {}, void 0) }, void 0)] }, index));
                    }) }, void 0), !values.length && _jsx(Divider, {}, void 0), _jsx("div", { children: _jsxs(Button, { id: "add-button", variant: "link", isSmall: true, "aria-label": "Action", onClick: onNewKey, children: [_jsx(PlusIcon, {}, void 0), " \u00A0 ", props.placeholder ?? 'Add'] }, void 0) }, void 0)] }, void 0) }, void 0));
}
export function StringsMapInput(props) {
    const { displayMode: mode, value, setValue, id, hidden } = useInput(props);
    let values = value;
    if (props.map)
        values = props.map(values);
    else if (!values)
        values = [];
    const onKeyChange = (index, newKey) => {
        values[index] = newKey;
        let newValue = values;
        if (props.unmap)
            newValue = props.unmap(values);
        setValue(newValue);
    };
    const onNewKey = () => {
        values.push('');
        let newValue = values;
        if (props.unmap)
            newValue = props.unmap(values);
        setValue(newValue);
    };
    const onDeleteKey = (index) => {
        values.splice(index, 1);
        let newValue = values;
        if (props.unmap)
            newValue = props.unmap(values);
        setValue(newValue);
    };
    if (hidden) {
        return _jsx(Fragment, {}, void 0);
    }
    if (mode === DisplayMode.Details) {
        if (!values.length)
            return _jsx(Fragment, {}, void 0);
        return (_jsxs(DescriptionListGroup, { children: [_jsx(DescriptionListTerm, { children: props.label }, void 0), _jsx(DescriptionListDescription, { id: id, children: _jsx("div", { style: { display: 'flex', flexDirection: 'column', rowGap: 8 }, children: values.map((value, index) => {
                            if (!value)
                                return _jsx(Fragment, {}, index);
                            return _jsx("div", { children: value }, index);
                        }) }, void 0) }, void 0)] }, void 0));
    }
    return (_jsx(InputLabel, { ...props, id: id, children: _jsxs("div", { id: id, style: { display: 'flex', flexDirection: 'column', rowGap: values.length ? 8 : 4 }, children: [_jsx("div", { style: { display: 'flex', flexDirection: 'column', rowGap: 8 }, children: values.map((pair, index) => {
                        return (_jsxs(InputGroup, { children: [_jsx(PFTextInput, { id: `${id}-${index + 1}`, value: pair, onChange: (e) => onKeyChange(index, e), required: true }, void 0), _jsx(Button, { variant: "plain", isDisabled: props.required === true && values.length === 1, "aria-label": "Remove item", onClick: () => onDeleteKey(index), style: { alignSelf: 'start' }, children: _jsx(TrashIcon, {}, void 0) }, void 0)] }, index));
                    }) }, void 0), !values.length && _jsx(Divider, {}, void 0), _jsx("div", { children: _jsxs(Button, { id: "add-button", variant: "link", isSmall: true, "aria-label": "Action", onClick: onNewKey, children: [_jsx(PlusIcon, {}, void 0), " \u00A0 ", props.placeholder ?? 'Add'] }, void 0) }, void 0)] }, void 0) }, void 0));
}
//# sourceMappingURL=StringsInput.js.map
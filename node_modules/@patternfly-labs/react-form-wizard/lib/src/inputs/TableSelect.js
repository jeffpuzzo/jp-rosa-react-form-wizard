import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { DescriptionListDescription, DescriptionListGroup, DescriptionListTerm, Dropdown, DropdownItem, DropdownPosition, DropdownToggle, DropdownToggleCheckbox, List, ListItem, Pagination, PaginationVariant, } from '@patternfly/react-core';
import { TableComposable, Tbody, Td, Th, Thead, Tr } from '@patternfly/react-table';
import { Fragment, useCallback, useMemo, useState } from 'react';
import { Indented } from '../components/Indented';
import { DisplayMode } from '../contexts/DisplayModeContext';
import { useInput } from './Input';
import { InputLabel } from './InputLabel';
export function TableSelect(props) {
    const { displayMode: mode, value, setValue, hidden, id } = useInput(props);
    const [page, setPage] = useState(1);
    const onSetPage = useCallback((_, page) => setPage(page), []);
    const pagedItems = useMemo(() => {
        return props.items.slice((page - 1) * 10, page * 10);
    }, [page, props.items]);
    let values = value;
    if (!Array.isArray(values))
        values = [];
    let selectedItems = values;
    if (props.valueMatchesItem)
        selectedItems = values
            .map((value) => props.items.find((item) => (props.valueMatchesItem ? props.valueMatchesItem(value, item) : false)))
            .filter((item) => item !== undefined);
    const onSelect = useCallback((item, select) => {
        if (select) {
            if (!selectedItems.includes(item)) {
                setValue([
                    ...(props.itemToValue ? selectedItems.map(props.itemToValue) : selectedItems),
                    props.itemToValue ? props.itemToValue(item) : pagedItems,
                ]);
            }
        }
        else {
            if (props.itemToValue) {
                setValue(selectedItems.filter((i) => i !== item).map(props.itemToValue));
            }
            else {
                setValue(selectedItems.filter((i) => i !== item));
            }
        }
    }, [pagedItems, props, selectedItems, setValue]);
    const isSelected = useCallback((item) => selectedItems.includes(item), [selectedItems]);
    const selectAll = useCallback(() => setValue(props.itemToValue ? props.items.map(props.itemToValue) : props.items), [props.items, props.itemToValue, setValue]);
    const selectPage = useCallback(() => {
        let newValue = [
            ...(props.itemToValue ? selectedItems.map(props.itemToValue) : selectedItems),
            ...(props.itemToValue ? pagedItems.map(props.itemToValue) : pagedItems),
        ];
        newValue = newValue.filter(onlyUnique);
        setValue(newValue);
    }, [pagedItems, props.itemToValue, selectedItems, setValue]);
    const selectNone = useCallback(() => setValue([]), [setValue]);
    if (hidden)
        return _jsx(Fragment, {}, void 0);
    if (mode === DisplayMode.Details) {
        if (!selectedItems.length)
            return _jsx(Fragment, {}, void 0);
        if (!props.label) {
            if (values.length > 5) {
                return _jsxs("div", { id: id, children: [values.length, " selected"] }, void 0);
            }
            return (_jsx(List, { isPlain: props.summaryList !== true, children: values.map((value, index) => (_jsx(ListItem, { style: { paddingBottom: 4 }, children: value }, index))) }, void 0));
        }
        if (values.length > 5) {
            return (_jsxs(DescriptionListGroup, { children: [_jsx(DescriptionListTerm, { children: props.label }, void 0), _jsxs(DescriptionListDescription, { id: id, children: [values.length, " selected"] }, void 0)] }, void 0));
        }
        return (_jsxs(Fragment, { children: [_jsx("div", { className: "pf-c-description-list__term", children: props.label }, void 0), _jsx(Indented, { paddingBottom: 4, children: _jsx(List, { style: { marginTop: -4 }, isPlain: props.summaryList !== true, children: values.map((value, index) => (_jsx(ListItem, { style: { paddingBottom: 4 }, children: value }, index))) }, void 0) }, void 0)] }, void 0));
    }
    if (props.items.length === 0) {
        return _jsx("div", { children: props.emptyMessage }, void 0);
    }
    return (_jsxs(InputLabel, { ...props, children: [_jsx("div", { style: { display: 'flex', gap: 8 }, children: _jsx(BulkSelect, { selectedCount: selectedItems.length, selectAll: selectAll, selectPage: selectPage, selectNone: selectNone, perPage: 10, total: props.items.length }, void 0) }, void 0), _jsxs(TableComposable, { "aria-label": props.label, variant: "compact", id: id, children: [_jsx(Thead, { children: _jsxs(Tr, { children: [_jsx(Th, {}, void 0), props.columns.map((column) => (_jsx(Th, { children: column.name }, column.name)))] }, void 0) }, void 0), _jsx(Tbody, { children: pagedItems.map((item, index) => (_jsxs(Tr, { children: [_jsx(Td, { select: {
                                        rowIndex: index,
                                        onSelect: (_event, isSelecting) => onSelect(item, isSelecting),
                                        isSelected: isSelected(item),
                                    } }, void 0), props.columns.map((column) => (_jsx(Td, { children: column.cellFn(item) }, column.name)))] }, index))) }, void 0)] }, void 0), props.items.length > 10 && (_jsx(Pagination, { itemCount: props.items.length, perPage: 10, variant: PaginationVariant.bottom, page: page, onSetPage: onSetPage, perPageOptions: [] }, void 0))] }, void 0));
}
function BulkSelect(props) {
    const [open, setOpen] = useState(false);
    const onDropDownToggle = useCallback(() => setOpen((open) => !open), []);
    const allSelected = props.selectedCount === props.total;
    const anySelected = props.selectedCount > 0;
    const someChecked = props.selectedCount ? null : false;
    const isChecked = allSelected ? true : someChecked;
    const items = useMemo(() => {
        const dropdownItems = [
            _jsx(DropdownItem, { onClick: props.selectNone, children: "Select none (0 items)" }, "item-1"),
        ];
        if (props.total > props.perPage) {
            dropdownItems.push(_jsxs(DropdownItem, { onClick: props.selectPage, children: ["Select page (", props.perPage, " items)"] }, "item-2"));
        }
        dropdownItems.push(_jsxs(DropdownItem, { onClick: props.selectAll, children: ["Select all (", props.total, " items)"] }, "item-3"));
        return dropdownItems;
    }, [props.perPage, props.selectAll, props.selectNone, props.selectPage, props.total]);
    const { selectNone, selectAll } = props;
    const onCheckbox = useCallback(() => {
        anySelected ? selectNone() : selectAll();
    }, [anySelected, selectNone, selectAll]);
    const splitButtonItems = useMemo(() => [
        _jsx(DropdownToggleCheckbox, { id: "example-checkbox-2", "aria-label": anySelected ? 'Deselect all' : 'Select all', isChecked: isChecked, onClick: onCheckbox }, "split-checkbox"),
    ], [anySelected, isChecked, onCheckbox]);
    const toggle = useMemo(() => (_jsx(DropdownToggle, { splitButtonItems: splitButtonItems, onToggle: onDropDownToggle, children: props.selectedCount !== 0 && _jsxs(Fragment, { children: [props.selectedCount, " selected"] }, void 0) }, void 0)), [onDropDownToggle, props.selectedCount, splitButtonItems]);
    return _jsx(Dropdown, { onSelect: onDropDownToggle, toggle: toggle, isOpen: open, dropdownItems: items, position: DropdownPosition.left }, void 0);
}
function onlyUnique(value, index, self) {
    return self.indexOf(value) === index;
}
//# sourceMappingURL=TableSelect.js.map
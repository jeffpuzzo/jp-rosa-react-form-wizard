import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Button, Flex, FlexItem, SelectOption, Split, Stack } from '@patternfly/react-core';
import { GitAltIcon, PlusIcon } from '@patternfly/react-icons';
import Handlebars from 'handlebars';
import { Fragment, useEffect, useMemo, useState } from 'react';
import { ArrayInput, Checkbox, Hidden, KeyValue, Multiselect, Radio, RadioGroup, Section, Select, Step, TextDetail, TextInput, Tile, Tiles, TimeRange, WizardPage, } from '../../src';
import { useData } from '../../src/contexts/DataContext';
import { useItem } from '../../src/contexts/ItemContext';
import ApplicationHandlebars from './applicationTemplates/App.hbs';
import ArgoAppSetHandlebars from './applicationTemplates/argoApplicationSet/ArgoApplication.hbs';
import ArgoTemplateGit from './applicationTemplates/argoApplicationSet/templateArgoGit.hbs';
import ArgoTemplateHelm from './applicationTemplates/argoApplicationSet/templateArgoHelm.hbs';
import ArgoTemplatePlacement from './applicationTemplates/argoApplicationSet/templateArgoPlacement.hbs';
import SubscriptionHandlebars from './applicationTemplates/subscription/Application.hbs';
import SubscriptionGitHandlebars from './applicationTemplates/subscription/templateSubscriptionGit.hbs';
import SubscriptionHelmHandlebars from './applicationTemplates/subscription/templateSubscriptionHelm.hbs';
import SubscriptionObjHandlebars from './applicationTemplates/subscription/templateSubscriptionObj.hbs';
import SubscriptionPlacementHandlebars from './applicationTemplates/subscription/templateSubscriptionPlacement.hbs';
import ArgoIcon from './logos/ArgoIcon.svg';
import HelmIcon from './logos/HelmIcon.svg';
import ObjectStore from './logos/ObjectStore.svg';
import SubscriptionIcon from './logos/SubscriptionIcon.svg';
export function ApplicationWizard(props) {
    Handlebars.registerPartial('templateSubscription', Handlebars.compile(SubscriptionHandlebars));
    Handlebars.registerPartial('templateSubscription', Handlebars.compile(SubscriptionHandlebars));
    Handlebars.registerPartial('templateSubscriptionGit', Handlebars.compile(SubscriptionGitHandlebars));
    Handlebars.registerPartial('templateSubscriptionHelm', Handlebars.compile(SubscriptionHelmHandlebars));
    Handlebars.registerPartial('templateSubscriptionObj', Handlebars.compile(SubscriptionObjHandlebars));
    Handlebars.registerPartial('templateSubscriptionPlacement', Handlebars.compile(SubscriptionPlacementHandlebars));
    Handlebars.registerPartial('templateArgoCD', Handlebars.compile(ArgoAppSetHandlebars));
    Handlebars.registerPartial('templateArgoGit', Handlebars.compile(ArgoTemplateGit));
    Handlebars.registerPartial('templateArgoHelm', Handlebars.compile(ArgoTemplateHelm));
    Handlebars.registerPartial('templateArgoPlacement', Handlebars.compile(ArgoTemplatePlacement));
    const reconcileOptions = useMemo(() => ['merge', 'replace'], []);
    const reconcileRates = useMemo(() => ['medium', 'low', 'high', 'off'], []);
    const requeueTimes = useMemo(() => [30, 60, 120, 180, 300], []);
    const urls = useMemo(() => ['url1', 'url2'], []);
    const urlOptions = useMemo(() => ['url1', 'url2'], []);
    const gitChannels = useMemo(() => props.channels.filter((channel) => channel.spec.type === 'Git' || channel.spec.type === 'GitHub'), [props.channels]);
    const helmChannels = useMemo(() => props.channels.filter((channel) => channel.spec.type === 'HelmRepo'), [props.channels]);
    const subscriptionGitChannels = gitChannels.map((gitChannel) => {
        const { name, namespace } = gitChannel.metadata;
        const { pathname } = gitChannel.spec;
        return {
            name: name || '',
            namespace: namespace || '',
            pathname: pathname || '',
        };
    });
    return (_jsxs(WizardPage, { title: "Create application", template: ApplicationHandlebars, defaultData: { curlyServer: '{{server}}', curlyName: '{{name}}', uniqueGroupID: 1 }, onCancel: props.onCancel, onSubmit: props.onSubmit, children: [_jsx(Step, { id: "type", label: "Type", children: _jsx(Section, { label: "Type", prompt: "Type", children: _jsxs(Tiles, { path: "deployType", label: "Select the application management type to deploy this application into clusters.", children: [_jsx(Tile, { id: "subscription", value: "Subscription", label: "Subscription", icon: _jsx(SubscriptionIcon, {}, void 0), description: "Subscriptions are Kubernetes resources within channels (source repositories)" }, void 0), _jsx(Tile, { id: "argoCD", value: "ArgoCD", label: "Argo CD ApplicationSet", icon: _jsx(ArgoIcon, {}, void 0), description: "Supports deployments to large numbers of clusters, deployments of large monorepos, and enabling secure Application self-service." }, void 0)] }, void 0) }, void 0) }, void 0), _jsx(Step, { id: "details", label: "Details", hidden: (item) => item.deployType !== 'Subscription', children: _jsx(DetailsSection, { namespaces: props.namespaces }, void 0) }, void 0), _jsx(Step, { id: "repositories", label: "Repositories", hidden: (item) => item.deployType !== 'Subscription', children: _jsx(Section, { label: "Repositories", prompt: "Enter the application repositories", children: _jsxs(ArrayInput, { path: "repositories", placeholder: "Add repository", collapsedContent: _jsxs(Fragment, { children: [_jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'SubscriptionGit', children: [_jsx(GitAltIcon, {}, void 0), _jsx(TextDetail, { path: "subscription.git.url", placeholder: "Expand to enter the repository details" }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'SubscriptionHelm', children: [_jsx(HelmIcon, {}, void 0), _jsx(TextDetail, { path: "subscription.helm.url", placeholder: "Expand to enter the repository details" }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'SubscriptionObjectstorage', children: [_jsx(ObjectStore, {}, void 0), _jsx(TextDetail, { path: "subscription.obj.url", placeholder: "Expand to enter the repository details" }, void 0)] }, void 0)] }, void 0), children: [_jsxs(Tiles, { path: "repositoryType", label: "Repository type", children: [_jsx(Tile, { id: "git", value: "SubscriptionGit", label: "Git", icon: _jsx(GitAltIcon, {}, void 0), description: "Use a Git repository" }, void 0), _jsx(Tile, { id: "helm", value: "SubscriptionHelm", label: "Helm", icon: _jsx(HelmIcon, {}, void 0), description: "Use a Helm repository" }, void 0), _jsx(Tile, { id: "objectstorage", value: "SubscriptionObjectstorage", icon: _jsx(ObjectStore, {}, void 0), label: "Object Storage", description: "Use a bucket from an object storage repository" }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'SubscriptionGit', children: [_jsx(Select, { path: "subscription.git.url", label: "URL", placeholder: "Enter or select a Git URL", labelHelp: "The URL path for the Git repository.", options: subscriptionGitChannels.map((gitChannel) => ({
                                            label: gitChannel.pathname,
                                            value: `${gitChannel.namespace}/${gitChannel.name}`,
                                        })), required: true }, void 0), _jsx(TextInput, { path: "subscription.git.username", label: "Username", placeholder: "Enter the Git user name", labelHelp: "The username if this is a private Git repository and requires connection." }, void 0), _jsx(TextInput, { path: "subscription.git.accessToken", label: "Access token", placeholder: "Enter the Git access token", labelHelp: "The access token if this is a private Git repository and requires connection." }, void 0), _jsx(Select, { path: "subscription.git.branch", label: "Branch", placeholder: "Enter or select a branch", labelHelp: "The branch of the Git repository.", options: ['branch-1'], required: true }, void 0), _jsx(Select, { path: "subscription.git.path", label: "Path", placeholder: "Enter or select a repository path", labelHelp: "The location of the resources on the Git repository.", options: urls, required: true }, void 0), _jsx(TextInput, { path: "subscription.git.commitHash", label: "Commit hash", placeholder: "Enter a specific commit hash", labelHelp: "If you want to subscribe to a specific commit, you need to specify the desired commit hash. You might need to specify git-clone-depth annotation if your desired commit is older than the last 20 commits." }, void 0), _jsx(TextInput, { path: "subscription.git.tag", label: "Tag", placeholder: "Enter a specific tag", labelHelp: "If you want to subscribe to a specific tag, you need to specify the tag. If both Git desired commit and tag annotations are specified, the tag is ignored. You might need to specify git-clone-depth annotation if your desired commit of the tag is older than the last 20 commits." }, void 0), _jsx(Select, { path: "subscription.git.reconcileOption", label: "Reconcile option", labelHelp: "With the Merge option, new fields are added and existing fields are updated in the resource. Choose to merge if resources are updated after the initial deployment. If you choose to replace, the existing resource is replaced with the Git source.", options: reconcileOptions, required: true }, void 0), _jsx(Select, { path: "subscription.git.reconcileRate", label: "Repository reconcile rate", labelHelp: "The frequency of resource reconciliation that is used as a global repository setting. The medium default setting checks for changes to apply every three minutes and re-applies all resources every 15 minutes, even without a change. Select low to reconcile every hour. Select high to reconcile every two minutes. If you select off, the deployed resources are not automatically reconciled.", options: reconcileRates }, void 0), _jsx(Checkbox, { path: "subscription.git.subReconcileRate", label: "Disable auto-reconciliation", labelHelp: "Turn the auto-reconciliation off for this specific application regardless of the reconcile rate setting in the repository." }, void 0), _jsx(Checkbox, { path: "subscription.git.insecureSkipVerify", label: "Disable server certificate verification", labelHelp: "Disable server TLS certificate verification for Git server connection." }, void 0), _jsx(AnsibleCredentials, { ansibleCredentials: props.ansibleCredentials }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'SubscriptionHelm', children: [_jsx(Select, { path: "subscription.helm.url", label: "URL", placeholder: "Enter or select a Helm repository URL", labelHelp: "The URL path for the Helm repository.", options: helmChannels.map((channel) => channel.metadata.name), required: true }, void 0), _jsx(TextInput, { path: "subscription.helm.username", label: "Username", placeholder: "Enter the Helm repository username", labelHelp: "The username if this is a private Helm repository and requires connection." }, void 0), _jsx(TextInput, { path: "subscription.helm.password", label: "Password", placeholder: "Enter the Helm repository password", labelHelp: "The password if this is a private Helm repository and requires connection." }, void 0), _jsx(TextInput, { path: "subscription.helm.chart", label: "Chart name", placeholder: "Enter the name of the target Helm chart", labelHelp: "The specific name for the target Helm chart.", required: true }, void 0), _jsx(TextInput, { path: "subscription.helm.packageAlias", label: "Package alias", placeholder: "Enter the alias name of the target Helm chart", labelHelp: "The alias name for the target Helm chart.", required: true }, void 0), _jsx(TextInput, { path: "subscription.helm.packageVersion", label: "Package version", placeholder: "Enter the version or versions", labelHelp: "The version or versions for the deployable. You can use a range of versions in the form >1.0, or <3.0." }, void 0), _jsx(Select, { path: "subscription.helm.reconcileRate", label: "Repository reconcile rate", labelHelp: "The frequency of resource reconciliation that is used as a global repository setting. The medium default setting checks for changes to apply every three minutes and re-applies all resources every 15 minutes, even without a change. Select low to reconcile every hour. Select high to reconcile every two minutes. If you select off, the deployed resources are not automatically reconciled.", options: reconcileRates, required: true }, void 0), _jsx(Checkbox, { path: "subscription.helm.subReconcileRate", label: "Disable auto-reconciliation", labelHelp: "Turn the auto-reconciliation off for this specific application regardless of the reconcile rate setting in the repository." }, void 0), _jsx(Checkbox, { path: "subscription.helm.insecureSkipVerify", label: "Disable server certificate verification", labelHelp: "Disable server TLS certificate verification for Git server connection." }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'SubscriptionObjectstorage', children: [_jsx(Select, { path: "subscription.obj.url", label: "URL", placeholder: "Enter or select an ObjectStore bucket URL", labelHelp: "The URL path for the object store.", options: urls, required: true }, void 0), _jsx(TextInput, { path: "subscription.obj.accessKey", label: "Access key", placeholder: "Enter the object store access key", labelHelp: "The access key for accessing the object store." }, void 0), _jsx(TextInput, { path: "subscription.obj.secretKey", label: "Secret key", placeholder: "Enter the object store secret key", labelHelp: "The secret key for accessing the object store." }, void 0), _jsx(TextInput, { path: "subscription.obj.region", label: "Region", placeholder: "Enter the AWS region of the S3 bucket", labelHelp: "The AWS Region of the S3 bucket. This field is required for Amazon S3 buckets only." }, void 0), _jsx(TextInput, { path: "subscription.obj.subfolder", label: "Subfolder", placeholder: "Enter the Amazon S3 or MinIO subfolder bucket path", labelHelp: "The Amazon S3 or MinIO subfolder bucket path. This field is optional for Amazon S3 and MinIO only." }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.repositoryType === undefined, children: [_jsx(Placement, { placement: props.placements }, void 0), _jsx(DeploymentWindow, { timeZone: props.timeZones }, void 0)] }, void 0)] }, void 0) }, void 0) }, void 0), _jsx(Step, { id: "general", label: "General", hidden: (item) => item.deployType !== 'ArgoCD', children: _jsxs(Section, { label: "General", children: [_jsx(TextInput, { path: "appSetName", label: "ApplicationSet name", placeholder: "Enter the application set name", required: true }, void 0), _jsx(Select, { path: "argoServer", label: "Argo server", placeholder: "Select the Argo server", labelHelp: "Argo server to deploy Argo app set. Click the Add cluster sets tab to create a new cluster set.", options: props.argoServers, required: true }, void 0), _jsx(ExternalLinkButton, { id: "addClusterSets", icon: _jsx(PlusIcon, {}, void 0), href: props.addClusterSets }, void 0), _jsx(Select, { path: "requeueTime", label: "Requeue time", options: requeueTimes, labelHelp: "Cluster decision resource requeue time in seconds", required: true }, void 0)] }, void 0) }, void 0), _jsxs(Step, { id: "template", label: "Template", hidden: (item) => item.deployType !== 'ArgoCD', children: [_jsxs(Section, { label: "Source", children: [_jsxs(Tiles, { path: "repositoryType", label: "Repository type", children: [_jsx(Tile, { id: "git", value: "Git", label: "Git", icon: _jsx(GitAltIcon, {}, void 0), description: "Use a Git repository" }, void 0), _jsx(Tile, { id: "helm", value: "Helm", label: "Helm", icon: _jsx(HelmIcon, {}, void 0), description: "Use a Helm repository" }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'Git', children: [_jsx(Select, { path: "git.url", label: "URL", labelHelp: "The URL path for the Git repository.", placeholder: "Enter or select a Git URL", options: subscriptionGitChannels.map((gitChannel) => ({
                                            label: gitChannel.pathname,
                                            value: `${gitChannel.namespace}/${gitChannel.name}`,
                                        })), required: true }, void 0), _jsx(Select, { path: "git.revision", label: "Revision", labelHelp: "Refer to a single commit", placeholder: "Enter or select a tracking revision", options: ['Branches', 'Tags'] }, void 0), _jsx(Select, { path: "git.path", label: "Path", labelHelp: "The location of the resources on the Git repository.", placeholder: "Enter or select a repository path", options: urlOptions }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'Helm', children: [_jsx(Select, { path: "helm.url", label: "URL", labelHelp: "The URL path for the Helm repository.", placeholder: "Enter or select a Helm URL", options: helmChannels.map((channel) => channel.metadata.name), required: true }, void 0), _jsx(TextInput, { path: "helm.chart", label: "Chart name", placeholder: "Enter the name of the Helm chart", labelHelp: "The specific name for the target Helm chart.", required: true }, void 0), _jsx(TextInput, { path: "helm.packageVersion", label: "Package version", placeholder: "Enter the version or versions", labelHelp: "The version or versions for the deployable. You can use a range of versions in the form >1.0, or <3.0.", required: true }, void 0)] }, void 0)] }, void 0), _jsx(Section, { label: "Destination", children: _jsx(TextInput, { path: "remoteNamespace", label: "Remote namespace", placeholder: "Enter the destination namespace", required: true }, void 0) }, void 0)] }, void 0), _jsx(Step, { id: "sync-policy", label: "Sync policy", hidden: (item) => item.deployType !== 'ArgoCD', children: _jsxs(Section, { label: "Sync policy", description: "Settings used to configure application syncing when there are differences between the desired state and the live cluster state.", children: [_jsxs(Hidden, { hidden: (data) => data.repositoryType !== 'Git', children: [_jsx(Checkbox, { path: "syncPolicy.prune", label: "Delete resources that are no longer defined in Git" }, void 0), _jsx(Checkbox, { path: "syncPolicy.pruneLast", label: "Delete resources that are no longer defined in Git at the end of a sync operation" }, void 0), _jsx(Checkbox, { path: "syncPolicy.replace", label: "Replace resources instead of applying changes from Git" }, void 0)] }, void 0), _jsx(Checkbox, { path: "syncPolicy.allowEmpty", label: "Allow applications to have empty resources" }, void 0), _jsx(Checkbox, { path: "syncPolicy.applyOutOfSyncOnly", label: "Only synchronize out-of-sync resources" }, void 0), _jsx(Checkbox, { path: "syncPolicy.selfHeal", label: "Automatically sync when cluster state changes" }, void 0), _jsx(Checkbox, { path: "syncPolicy.createNamespace", label: "Automatically create namespace if it does not exist" }, void 0), _jsx(Checkbox, { path: "syncPolicy.validate", label: "Disable kubectl validation" }, void 0), _jsx(Checkbox, { path: "syncPolicy.prunePropagationPolicy", label: "Prune propagation policy", children: _jsx(Select, { path: "syncPolicy.propagationPolicy", label: "Propogation policy", options: ['foreground', 'background', 'orphan'], required: true }, void 0) }, void 0)] }, void 0) }, void 0), _jsx(Step, { id: "placement", label: "Placement", hidden: (item) => item.deployType !== 'ArgoCD', children: _jsx(Placement, { placement: props.placements }, void 0) }, void 0)] }, void 0));
}
export function Placement(props) {
    return (_jsx(Fragment, { children: _jsxs(Section, { label: "Cluster placement", description: "Applications are deployed to clusters based on placements", children: [_jsx(Checkbox, { path: "placement.useLabels", label: "New placement", labelHelp: "Deploy application resources only on clusters matching specified labels", children: _jsx(KeyValue, { path: "placement.labels", label: "Cluster labels", placeholder: "Enter cluster labels", helperText: "Placement will only select clusters matching all the specified labels", required: true }, void 0) }, void 0), _jsx(Checkbox, { path: "placement.useExisting", label: "Use an existing placement", labelHelp: "If available in the application namespace, you can select a predefined placement configuration", children: _jsx(Select, { path: "placement.select", label: "Placement", placeholder: "Select an existing placement", options: props.placement, required: true }, void 0) }, void 0)] }, void 0) }, void 0));
}
export function AnsibleCredentials(props) {
    return (_jsx(Section, { label: "Configure automation for prehook and posthook", children: _jsx(Select, { path: "subscription.git.ansibleSecretName", label: "Ansible Automation Platform credential", labelHelp: "If using Configure automation for prehook and posthook tasks, select the Ansible Automation Platform credential. Click the Add credentials tab to create a new secret.", options: props.ansibleCredentials }, void 0) }, void 0));
}
export function DeploymentWindow(props) {
    return (_jsx(Section, { hidden: (data) => {
            return data.deployType === 'ArgoCD';
        }, id: "deploymentWindow.title", label: "Deployment window", description: "Schedule a time window for deployments", labelHelp: "Define a time window if you want to activate or block resources deployment within a certain time interval.", children: _jsxs(RadioGroup, { id: "remediation", path: "deployment.window", required: true, children: [_jsx(Radio, { id: "always", label: "Always active", value: "always" }, void 0), _jsx(Radio, { id: "active", label: "Active within specified interval", value: "active", children: _jsx(TimeWindow, { timeZone: props.timeZone }, void 0) }, void 0), _jsx(Radio, { id: "blocked", label: "Blocked within specified interval", value: "blocked", children: _jsx(TimeWindow, { timeZone: props.timeZone }, void 0) }, void 0)] }, void 0) }, void 0));
}
export function TimeWindow(props) {
    return (_jsxs(Stack, { hasGutter: true, style: { paddingBottom: 16 }, children: [_jsx(Multiselect, { label: "Time window configuration", placeholder: "Select at least one day to create a time window.", path: "timewindow.daysofweek", required: true, children: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map((value) => (_jsx(SelectOption, { value: value }, value))) }, void 0), _jsx(Select, { path: "timeWindow.timezone", label: "Time zone", placeholder: "Select the time zone", options: props.timeZone, required: true }, void 0), _jsx(ArrayInput, { path: "timeWindows", placeholder: "Add time range", collapsedContent: _jsxs(Fragment, { children: [_jsx(TextDetail, { path: "start", placeholder: "Expand to enter the variable" }, void 0), _jsxs(Hidden, { hidden: (item) => item.end === undefined, children: ["\u00A0-\u00A0", _jsx(TextDetail, { path: "end" }, void 0)] }, void 0)] }, void 0), children: _jsxs(Split, { hasGutter: true, children: [_jsx(TimeRange, { path: "start", label: "Start Time" }, void 0), _jsx(TimeRange, { path: "end", label: "End Time" }, void 0)] }, void 0) }, void 0)] }, void 0));
}
export function ExternalLinkButton(props) {
    return (_jsx(Flex, { children: _jsx(FlexItem, { spacer: { default: 'spacerXl' }, children: _jsx(Button, { id: props.id, icon: props.icon, isSmall: true, variant: "link", component: "a", href: props.href, target: "_blank", children: "Add cluster sets" }, void 0) }, void 0) }, void 0));
}
function DetailsSection(props) {
    const [newNamespaces, setNewNamespaces] = useState([]);
    const activeNamespaces = useMemo(() => [...props.namespaces, ...newNamespaces], [newNamespaces, props.namespaces]);
    const item = useItem();
    const data = useData();
    useEffect(() => {
        const namespace = item.namespace;
        if (!props.namespaces.includes(namespace)) {
            if (!item.newNamespace) {
                item.newNamespace = true;
                data.update();
            }
        }
        else {
            if (item.newNamespace) {
                item.newNamespace = false;
                data.update();
            }
        }
    }, [item, data, props.namespaces]);
    return (_jsxs(Section, { label: "Details", prompt: "Enter the details of the application", children: [_jsx(TextInput, { path: "name", label: "Application name", required: true }, void 0), _jsx(Select, { path: "namespace", label: "Namespace", placeholder: "Select the namespace", helperText: "The namespace on the hub cluster where the application resources will be created.", options: activeNamespaces, isCreatable: true, onCreate: (namespaceName) => setNewNamespaces([...newNamespaces, namespaceName]), required: true }, void 0)] }, void 0));
}
//# sourceMappingURL=ApplicationWizard.js.map
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Button, Flex, FlexItem, SelectOption, Split, Stack, ToggleGroup, ToggleGroupItem } from '@patternfly/react-core';
import { GitAltIcon, PlusIcon } from '@patternfly/react-icons';
import { Fragment, useMemo, useState } from 'react';
import { ArrayInput, Checkbox, DetailsHidden, EditMode, Hidden, ItemSelector, Multiselect, Radio, RadioGroup, Section, Select, Step, TextDetail, TextInput, Tile, Tiles, TimeRange, WizardPage, } from '../../src';
import { useData } from '../../src/contexts/DataContext';
import { useEditMode } from '../../src/contexts/EditModeContext';
import { useItem } from '../../src/contexts/ItemContext';
import { PlacementApiVersion, PlacementKind, PlacementType } from '../common/resources/IPlacement';
import { Sync } from '../common/Sync';
import { Placement } from '../Placement/Placement';
import HelmIcon from './logos/HelmIcon.svg';
export function ArgoWizard(props) {
    const requeueTimes = useMemo(() => [30, 60, 120, 180, 300], []);
    const gitChannels = useMemo(() => {
        if (props.channels)
            return props.channels
                .filter((channel) => channel?.spec?.type === 'Git' || channel?.spec?.type === 'GitHub')
                .map((channel) => channel?.spec?.pathname);
        return undefined;
    }, [props.channels]);
    const helmChannels = useMemo(() => {
        if (props.channels)
            return props.channels.filter((channel) => channel?.spec?.type === 'HelmRepo').map((channel) => channel.spec.pathname);
        return undefined;
    }, [props.channels]);
    const [gitPaths, setGitPaths] = useState(undefined);
    const [gitRevisions, setGitRevisions] = useState(undefined);
    return (_jsxs(WizardPage, { title: "Create application set", defaultData: [
            {
                apiVersion: 'argoproj.io/v1alpha1',
                kind: 'ApplicationSet',
                metadata: { name: '', namespace: '' },
                spec: {
                    generators: [
                        {
                            clusterDecisionResource: {
                                configMapRef: 'acm-placement',
                                labelSelector: { matchLabels: { 'cluster.open-cluster-management.io/placement': '-placement' } },
                                requeueAfterSeconds: 180,
                            },
                        },
                    ],
                    template: {
                        metadata: { name: '-{{name}}' },
                        spec: { project: 'default', source: {}, destination: { namespace: '', server: '{{server}}' } },
                    },
                },
            },
            {
                ...PlacementType,
                metadata: { name: '', namespace: '' },
            },
        ], onCancel: props.onCancel, onSubmit: props.onSubmit, children: [_jsxs(Step, { id: "general", label: "General", children: [_jsx(Sync, { kind: PlacementKind, path: "metadata.name", targetKind: "ApplicationSet", targetPath: "spec.generators.0.clusterDecisionResource.labelSelector.matchLabels.cluster\\.open-cluster-management\\.io/placement" }, void 0), _jsx(Sync, { kind: "ApplicationSet", path: "metadata.name", prefix: "-placement" }, void 0), _jsx(Sync, { kind: "ApplicationSet", path: "metadata.namespace" }, void 0), _jsx(Sync, { kind: "ApplicationSet", path: "metadata.name", targetKind: "ApplicationSet", targetPath: "spec.template.metadata.name", postfix: "-{{name}}" }, void 0), _jsx(ItemSelector, { selectKey: "kind", selectValue: "ApplicationSet", children: _jsxs(Section, { label: "General", children: [_jsx(TextInput, { path: "metadata.name", label: "ApplicationSet name", placeholder: "Enter the application set name", required: true, id: "name" }, void 0), _jsx(Select, { id: "namespace", path: "metadata.namespace", label: "Argo server", placeholder: "Select the Argo server", labelHelp: "Argo server to deploy Argo app set. Click the Add cluster sets tab to create a new cluster set.", options: props.argoServers, required: true }, void 0), _jsx(DetailsHidden, { children: _jsx(ExternalLinkButton, { id: "addClusterSets", icon: _jsx(PlusIcon, {}, void 0), href: props.addClusterSets }, void 0) }, void 0), _jsx(Select, { path: "spec.generators.0.clusterDecisionResource.requeueAfterSeconds", label: "Requeue time", options: requeueTimes, labelHelp: "Cluster decision resource requeue time in seconds", required: true }, void 0)] }, void 0) }, void 0)] }, void 0), _jsx(Step, { id: "template", label: "Template", children: _jsxs(ItemSelector, { selectKey: "kind", selectValue: "ApplicationSet", children: [_jsxs(Section, { label: "Source", children: [_jsxs(Tiles, { path: "spec.template.spec.source", label: "Repository type", inputValueToPathValue: repositoryTypeToSource, pathValueToInputValue: sourceToRepositoryType, children: [_jsx(Tile, { id: "git", value: "Git", label: "Git", icon: _jsx(GitAltIcon, {}, void 0), description: "Use a Git repository" }, void 0), _jsx(Tile, { id: "helm", value: "Helm", label: "Helm", icon: _jsx(HelmIcon, {}, void 0), description: "Use a Helm repository" }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.spec.template.spec.source.path === undefined, children: [_jsx(Select, { path: "spec.template.spec.source.repoURL", label: "URL", labelHelp: "The URL path for the Git repository.", placeholder: "Enter or select a Git URL", options: gitChannels, onValueChange: (value) => {
                                                const channel = props.channels?.find((channel) => channel.spec.pathname === value);
                                                channel && getGitBranchList(channel, props.getGitRevisions, setGitRevisions);
                                            }, required: true }, void 0), _jsxs(Hidden, { hidden: (data) => data.spec.template.spec.source.repoURL === '', children: [_jsx(Select, { path: "spec.template.spec.source.targetRevision", label: "Revision", labelHelp: "Refer to a single commit", placeholder: "Enter or select a tracking revision", options: gitRevisions, onValueChange: (value, item) => {
                                                        const channel = props.channels?.find((channel) => channel?.spec?.pathname === item.spec.template.spec.source.repoURL);
                                                        channel && getGitPathList(channel, value, props.getGitPaths, setGitPaths);
                                                    } }, void 0), _jsx(Select, { path: "spec.template.spec.source.path", label: "Path", labelHelp: "The location of the resources on the Git repository.", placeholder: "Enter or select a repository path", options: gitPaths }, void 0)] }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (data) => data.spec.template.spec.source.chart === undefined, children: [_jsx(Select, { path: "spec.template.spec.source.repoURL", label: "URL", labelHelp: "The URL path for the Helm repository.", placeholder: "Enter or select a Helm URL", options: helmChannels, required: true }, void 0), _jsx(TextInput, { path: "spec.template.spec.source.chart", label: "Chart name", placeholder: "Enter the name of the Helm chart", labelHelp: "The specific name for the target Helm chart.", required: true }, void 0), _jsx(TextInput, { path: "spec.template.spec.source.targetRevision", label: "Package version", placeholder: "Enter the version or versions", labelHelp: "The version or versions for the deployable. You can use a range of versions in the form >1.0, or <3.0.", required: true }, void 0)] }, void 0)] }, void 0), _jsx(Section, { label: "Destination", children: _jsx(TextInput, { id: "destination", path: "spec.template.spec.destination.namespace", label: "Remote namespace", placeholder: "Enter the destination namespace", required: true }, void 0) }, void 0)] }, void 0) }, void 0), _jsx(Step, { id: "sync-policy", label: "Sync policy", children: _jsx(ItemSelector, { selectKey: "kind", selectValue: "ApplicationSet", children: _jsxs(Section, { label: "Sync policy", description: "Settings used to configure application syncing when there are differences between the desired state and the live cluster state.", children: [_jsxs(Hidden, { hidden: (data) => data.spec.template.spec.source.path === undefined, children: [_jsx(Checkbox, { label: "Delete resources that are no longer defined in Git", path: "spec.template.spec.syncPolicy.automated.prune" }, void 0), _jsx(Checkbox, { id: "prune-last", label: "Delete resources that are no longer defined in Git at the end of a sync operation", path: "spec.template.spec.syncPolicy.syncOptions", inputValueToPathValue: booleanToSyncOptions('PruneLast'), pathValueToInputValue: syncOptionsToBoolean('PruneLast') }, void 0), _jsx(Checkbox, { id: "replace", label: "Replace resources instead of applying changes from Git", path: "spec.template.spec.syncPolicy.syncOptions", inputValueToPathValue: booleanToSyncOptions('Replace'), pathValueToInputValue: syncOptionsToBoolean('Replace') }, void 0)] }, void 0), _jsx(Checkbox, { path: "spec.template.spec.syncPolicy.automated.allowEmpty", label: "Allow applications to have empty resources" }, void 0), _jsx(Checkbox, { id: "apply-out-of-sync-only", label: "Only synchronize out-of-sync resources", path: "spec.template.spec.syncPolicy.syncOptions", inputValueToPathValue: booleanToSyncOptions('ApplyOutOfSyncOnly'), pathValueToInputValue: syncOptionsToBoolean('ApplyOutOfSyncOnly') }, void 0), _jsx(Checkbox, { path: "spec.template.spec.syncPolicy.automated.selfHeal", label: "Automatically sync when cluster state changes" }, void 0), _jsx(Checkbox, { id: "create-namespace", label: "Automatically create namespace if it does not exist", path: "spec.template.spec.syncPolicy.syncOptions", inputValueToPathValue: booleanToSyncOptions('CreateNamespace'), pathValueToInputValue: syncOptionsToBoolean('CreateNamespace') }, void 0), _jsx(Checkbox, { id: "validate", label: "Disable kubectl validation", path: "spec.template.spec.syncPolicy.syncOptions", inputValueToPathValue: booleanToSyncOptions('Validate'), pathValueToInputValue: syncOptionsToBoolean('Validate') }, void 0), _jsx(Checkbox, { id: "propagation-policy", label: "Prune propagation policy", path: "spec.template.spec.syncPolicy.syncOptions", inputValueToPathValue: checkboxPrunePropagationPolicyToSyncOptions, pathValueToInputValue: checkboxSyncOptionsToPrunePropagationPolicy, children: _jsx(Select, { label: "Propogation policy", options: ['foreground', 'background', 'orphan'], path: "spec.template.spec.syncPolicy.syncOptions", inputValueToPathValue: prunePropagationPolicyToSyncOptions, pathValueToInputValue: syncOptionsToPrunePropagationPolicy, required: true }, void 0) }, void 0)] }, void 0) }, void 0) }, void 0), _jsx(Step, { id: "placement", label: "Cluster placement", children: _jsx(ArgoWizardPlacementSection, { placements: props.placements }, void 0) }, void 0)] }, void 0));
}
export function DeploymentWindow(props) {
    return (_jsx(Section, { hidden: (data) => {
            return data.deployType === 'ArgoCD';
        }, id: "deploymentWindow.title", label: "Deployment window", description: "Schedule a time window for deployments", labelHelp: "Define a time window if you want to activate or block resources deployment within a certain time interval.", children: _jsxs(RadioGroup, { id: "remediation", path: "deployment.window", required: true, children: [_jsx(Radio, { id: "always", label: "Always active", value: "always" }, void 0), _jsx(Radio, { id: "active", label: "Active within specified interval", value: "active", children: _jsx(TimeWindow, { timeZone: props.timeZone }, void 0) }, void 0), _jsx(Radio, { id: "blocked", label: "Blocked within specified interval", value: "blocked", children: _jsx(TimeWindow, { timeZone: props.timeZone }, void 0) }, void 0)] }, void 0) }, void 0));
}
export function TimeWindow(props) {
    return (_jsxs(Stack, { hasGutter: true, style: { paddingBottom: 16 }, children: [_jsx(Multiselect, { label: "Time window configuration", placeholder: "Select at least one day to create a time window.", path: "timewindow.daysofweek", required: true, children: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map((value) => (_jsx(SelectOption, { value: value }, value))) }, void 0), _jsx(Select, { path: "timeWindow.timezone", label: "Time zone", placeholder: "Select the time zone", options: props.timeZone, required: true }, void 0), _jsx(ArrayInput, { path: "timeWindows", placeholder: "Add time range", collapsedContent: _jsxs(Fragment, { children: [_jsx(TextDetail, { path: "start", placeholder: "Expand to enter the variable" }, void 0), _jsxs(Hidden, { hidden: (item) => item.end === undefined, children: ["\u00A0-\u00A0", _jsx(TextDetail, { path: "end" }, void 0)] }, void 0)] }, void 0), children: _jsxs(Split, { hasGutter: true, children: [_jsx(TimeRange, { path: "start", label: "Start Time" }, void 0), _jsx(TimeRange, { path: "end", label: "End Time" }, void 0)] }, void 0) }, void 0)] }, void 0));
}
async function getGitBranchList(channel, getGitBranches, setGitBranches) {
    await getGitBranches(channel.spec.pathname, {
        secretRef: channel.spec?.secretRef?.name,
        namespace: channel.metadata?.namespace,
    }).then((result) => {
        if (result) {
            setGitBranches(result);
        }
        else
            setGitBranches([]);
    });
}
async function getGitPathList(channel, branch, getGitPaths, setGitPaths) {
    await getGitPaths(channel?.spec?.pathname, branch, {
        secretRef: channel?.spec?.secretRef?.name,
        namespace: channel.metadata?.namespace,
    }).then((result) => {
        if (result) {
            setGitPaths(result);
        }
        else
            setGitPaths([]);
    });
}
export function ExternalLinkButton(props) {
    return (_jsx(Flex, { children: _jsx(FlexItem, { spacer: { default: 'spacerXl' }, children: _jsx(Button, { id: props.id, icon: props.icon, isSmall: true, variant: "link", component: "a", href: props.href, target: "_blank", children: "Add cluster sets" }, void 0) }, void 0) }, void 0));
}
function repositoryTypeToSource(value) {
    if (value === 'Git') {
        return {
            repoURL: '',
            targetRevision: '',
            path: '',
        };
    }
    if (value === 'Helm') {
        return {
            repoURL: '',
            chart: '',
            targetRevision: '',
        };
    }
    return value;
}
function sourceToRepositoryType(source) {
    if (typeof source === 'object' && source !== null) {
        const isGit = 'repoURL' in source && 'path' in source && 'targetRevision' in source;
        if (isGit)
            return 'Git';
        const isHelm = 'repoURL' in source && 'chart' in source && 'targetRevision' in source;
        if (isHelm)
            return 'Helm';
    }
    return undefined;
}
function booleanToSyncOptions(key) {
    return (value, array) => {
        let newArray;
        if (Array.isArray(array)) {
            newArray = array;
        }
        else {
            newArray = [];
        }
        const index = newArray.findIndex((entry) => typeof entry === 'string' && entry.startsWith(`${key}=`));
        if (typeof value === 'boolean') {
            if (index !== -1) {
                newArray[index] = `${key}=${value.toString()}`;
            }
            else {
                newArray.push(`${key}=${value.toString()}`);
            }
        }
        return newArray;
    };
}
function syncOptionsToBoolean(key) {
    return (array) => {
        if (Array.isArray(array))
            return array?.includes(`${key}=true`);
        return false;
    };
}
function checkboxPrunePropagationPolicyToSyncOptions(value, array) {
    let newArray;
    if (Array.isArray(array)) {
        newArray = array;
    }
    else {
        newArray = [];
    }
    if (typeof value === 'boolean') {
        const index = newArray.findIndex((entry) => typeof entry === 'string' && entry.startsWith(`PrunePropagationPolicy=`));
        if (value === true) {
            if (index === -1) {
                newArray.push(`PrunePropagationPolicy=background`);
            }
        }
        else {
            if (index !== -1) {
                newArray.splice(index, 1);
            }
        }
    }
    return newArray;
}
function checkboxSyncOptionsToPrunePropagationPolicy(array) {
    return (Array.isArray(array) &&
        array.find((entry) => typeof entry === 'string' && entry.startsWith(`PrunePropagationPolicy=`)) !== undefined);
}
function prunePropagationPolicyToSyncOptions(value, array) {
    let newArray;
    if (Array.isArray(array)) {
        newArray = array;
    }
    else {
        newArray = [];
    }
    const index = newArray.findIndex((entry) => typeof entry === 'string' && entry.startsWith(`PrunePropagationPolicy=`));
    if (typeof value === 'string') {
        if (index !== -1) {
            newArray[index] = `PrunePropagationPolicy=${value}`;
        }
        else {
            newArray.push(`PrunePropagationPolicy=${value}`);
        }
    }
    return newArray;
}
function syncOptionsToPrunePropagationPolicy(array) {
    if (Array.isArray(array)) {
        const index = array.findIndex((entry) => typeof entry === 'string' && entry.startsWith(`PrunePropagationPolicy=`));
        if (index !== -1) {
            const value = array[index];
            if (typeof value === 'string') {
                return value.slice('PrunePropagationPolicy='.length);
            }
        }
    }
    return 'background';
}
function ArgoWizardPlacementSection(props) {
    const resources = useItem();
    const editMode = useEditMode();
    const hasPlacement = resources.find((r) => r.kind === PlacementKind) !== undefined;
    const applicationSet = resources.find((r) => r.kind === 'ApplicationSet');
    const placements = props.placements.filter((placement) => placement.metadata?.namespace === applicationSet?.metadata?.namespace);
    const { update } = useData();
    return (_jsxs(Section, { label: "Cluster placement", children: [_jsx(DetailsHidden, { children: _jsxs("div", { style: { display: 'flex', flexDirection: 'column', gap: 8 }, children: [editMode === EditMode.Create && (_jsx("span", { className: "pf-c-form__label pf-c-form__label-text", children: "How do you want to select clusters?" }, void 0)), _jsxs(ToggleGroup, { children: [_jsx(ToggleGroupItem, { text: "New placement", isSelected: hasPlacement, onClick: () => {
                                        let newResources = [...resources];
                                        newResources = resources.filter((resource) => resource.kind !== PlacementKind);
                                        newResources.push({
                                            apiVersion: PlacementApiVersion,
                                            kind: PlacementKind,
                                            metadata: { name: '', namespace: '' },
                                        });
                                        update(newResources);
                                    } }, void 0), _jsx(ToggleGroupItem, { text: "Existing placement", isSelected: !hasPlacement, onClick: () => {
                                        let newResources = [...resources];
                                        newResources = resources.filter((resource) => resource.kind !== PlacementKind);
                                        update(newResources);
                                    } }, void 0)] }, void 0)] }, void 0) }, void 0), hasPlacement ? (_jsx(ItemSelector, { selectKey: "kind", selectValue: PlacementKind, children: _jsx(Placement, { namespaceClusterSetNames: [] }, void 0) }, void 0)) : (_jsx(ItemSelector, { selectKey: "kind", selectValue: "ApplicationSet", children: _jsx(Select, { path: "spec.generators.0.clusterDecisionResource.labelSelector.matchLabels.cluster\\.open-cluster-management\\.io/placement", label: "Existing placement", options: placements.map((placement) => placement.metadata?.name ?? '') }, void 0) }, void 0))] }, void 0));
}
//# sourceMappingURL=ArgoWizard.js.map
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Breadcrumb, BreadcrumbItem, Card, CardBody, CardHeader, CardTitle, Checkbox, Drawer, DrawerContent, DrawerContentBody, DrawerPanelBody, DrawerPanelContent, DrawerSection, Flex, FlexItem, Label, LabelGroup, List, ListItem, Page, PageSection, SearchInput, Split, SplitItem, Stack, Text, Title, } from '@patternfly/react-core';
import { CheckIcon } from '@patternfly/react-icons';
import Fuse from 'fuse.js';
import { Fragment, useCallback, useMemo, useState } from 'react';
import { Masonry } from './Demo';
const fuseCardOptions = {
    includeScore: true,
    keys: [
        { name: 'title', weight: 0.35 },
        { name: 'descriptions', weight: 0.15 },
        { name: 'featureGroups.features', weight: 0.15 },
        { name: 'labels', weight: 0.15 },
        { name: 'labels.label', weight: 0.15 },
        { name: 'badge', weight: 0.15 },
    ],
};
export function Catalog(props) {
    const breadcrumbs = useMemo(() => {
        if (!props.breadcrumbs)
            return _jsx(Fragment, {}, void 0);
        return (_jsx(Breadcrumb, { children: props.breadcrumbs.map((breadcrumb) => (_jsx(BreadcrumbItem, { id: breadcrumb.id, to: breadcrumb.to, target: breadcrumb.target, component: breadcrumb.component, children: breadcrumb.label }, breadcrumb.id))) }, void 0));
    }, [props.breadcrumbs]);
    const [search, setSearch] = useState('');
    const [filterSelections, setFilterSelections] = useState({});
    const onClickFilter = useCallback((filterGroup, filter) => {
        const newSelections = { ...filterSelections };
        const filterGroupSelections = newSelections[filterGroup.id];
        if (!filterGroupSelections) {
            newSelections[filterGroup.id] = [filter.value];
        }
        else {
            if (filterGroupSelections.includes(filter.value)) {
                filterGroupSelections.splice(filterGroupSelections.indexOf(filter.value), 1);
            }
            else {
                filterGroupSelections.push(filter.value);
            }
        }
        setFilterSelections(newSelections);
    }, [filterSelections]);
    const catalogFilterGroups = useMemo(() => {
        if (!props.filterGroups)
            return _jsx(Fragment, {}, void 0);
        return (_jsx(DrawerPanelContent, { minSize: "250px", defaultSize: "250px", maxSize: "250px", children: _jsx(DrawerPanelBody, { children: props.filterGroups.map((filterGroup) => (_jsx(DrawerSection, { style: { paddingBottom: 32 }, children: _jsx(FilterGroup, { filterGroup: filterGroup, selectedValues: filterSelections[filterGroup.id], onClickFilter: onClickFilter }, void 0) }, filterGroup.id))) }, void 0) }, void 0));
    }, [props.filterGroups, filterSelections, onClickFilter]);
    const filteredCards = useMemo(() => {
        let filteredCards = props.cards;
        if (!filteredCards)
            return undefined;
        if (Object.keys(filterSelections).length > 0) {
            for (const key in filterSelections) {
                const t = filterSelections[key];
                if (t.length == 0)
                    continue;
                filteredCards = filteredCards?.filter((card) => {
                    return card.labels?.find((label) => {
                        return t.includes(label);
                    });
                });
            }
        }
        return filteredCards;
    }, [props.cards, filterSelections]);
    const searchedCards = useMemo(() => {
        let activeCards = filteredCards;
        if (!activeCards)
            return undefined;
        if (search) {
            const fuse = new Fuse(activeCards, fuseCardOptions);
            activeCards = fuse.search(search).map((result) => result.item);
        }
        else {
            activeCards = activeCards?.sort((lhs, rhs) => lhs.title.localeCompare(rhs.title));
        }
        return activeCards;
    }, [filteredCards, search]);
    const catalogCards = useMemo(() => {
        if (!searchedCards)
            return _jsx(Fragment, {}, void 0);
        return (_jsx(Masonry, { size: 470, children: searchedCards.map((card) => (_jsxs(Card, { id: card.id, onClick: card.onClick, isFlat: true, isLarge: true, isSelectableRaised: true, children: [_jsx(CardHeader, { children: _jsxs(Split, { hasGutter: true, style: { width: '100%' }, children: [_jsx(SplitItem, { isFilled: true, children: _jsx(CardTitle, { children: card.title }, void 0) }, void 0), card.badge && (_jsx(SplitItem, { children: _jsx(Label, { isCompact: true, color: "orange", children: card.badge }, void 0) }, void 0))] }, void 0) }, void 0), _jsx(CardBody, { children: _jsxs("div", { style: { display: 'flex', flexDirection: 'column', gap: 32 }, children: [Array.isArray(card.descriptions) &&
                                    card.descriptions.map((description, index) => (_jsx(Text, { component: "p", children: description }, index))), Array.isArray(card.featureGroups) &&
                                    card.featureGroups.map((featureGroup, index) => (_jsxs(Stack, { children: [_jsx(Title, { headingLevel: "h6", style: { paddingBottom: 8 }, children: featureGroup.title }, void 0), _jsx(List, { isPlain: true, children: featureGroup.features?.map((feature, index) => (_jsx(ListItem, { icon: _jsx(CheckIcon, { color: "green", size: "md" }, void 0), children: feature }, index))) }, void 0)] }, index))), card.labels && (_jsx(LabelGroup, { numLabels: 999, children: card.labels.map((label) => (_jsx(Label, { children: label }, label))) }, void 0))] }, void 0) }, void 0)] }, card.id ?? card.title))) }, void 0));
    }, [searchedCards]);
    return (_jsxs(Page, { children: [_jsx(PageSection, { variant: "light", sticky: "top", isWidthLimited: true, children: _jsxs(Flex, { style: { gap: 16 }, children: [_jsx(FlexItem, { grow: { default: 'grow' }, children: _jsxs(Stack, { hasGutter: true, children: [breadcrumbs, _jsx(Title, { headingLevel: "h1", children: props.title }, void 0)] }, void 0) }, void 0), _jsx(FlexItem, { alignSelf: { default: 'alignSelfFlexEnd' }, grow: { default: 'grow' }, children: _jsx(SearchInput, { value: search, onChange: setSearch, onClear: () => setSearch('') }, void 0) }, void 0)] }, void 0) }, void 0), _jsx(PageSection, { variant: "light", padding: { default: 'noPadding' }, isFilled: true, hasOverflowScroll: true, isWidthLimited: true, children: _jsx(Drawer, { position: "left", isStatic: true, children: _jsx(DrawerContent, { panelContent: catalogFilterGroups, children: _jsx(DrawerContentBody, { hasPadding: true, children: catalogCards }, void 0) }, void 0) }, void 0) }, void 0)] }, void 0));
}
function FilterGroup(props) {
    const { filterGroup, selectedValues, onClickFilter } = props;
    return (_jsx(DrawerSection, { children: _jsxs(Stack, { hasGutter: true, children: [_jsx(Title, { headingLevel: "h4", children: filterGroup.label }, void 0), filterGroup.filters?.map((filter) => (_jsx(Filter, { filter: filter, selectedValues: selectedValues, onClick: () => onClickFilter(filterGroup, filter) }, filter.id ?? filter.value.toString())))] }, void 0) }, filterGroup.id));
}
function Filter(props) {
    const { filter, selectedValues, onClick } = props;
    return (_jsxs(Fragment, { children: [_jsx(Checkbox, { id: filter.id ?? filter.value.toString(), isChecked: selectedValues?.includes(filter.value), onChange: onClick, label: filter.label ?? filter.value.toString() }, void 0), filter.filters && (_jsx(Stack, { hasGutter: true, children: filter.filters.map((filter) => (_jsx(Filter, { filter: filter, selectedValues: selectedValues, onClick: onClick }, filter.id ?? filter.value.toString()))) }, void 0))] }, void 0));
}
//# sourceMappingURL=Catalog.js.map
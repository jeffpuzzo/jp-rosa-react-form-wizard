import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Flex, FlexItem } from '@patternfly/react-core';
import { Fragment } from 'react';
import { Select, StringsInput, TextInput } from '../../src';
import { DisplayMode, useDisplayMode } from '../../src/contexts/DisplayModeContext';
import { useItem } from '../../src/contexts/ItemContext';
export function MatchExpression() {
    return (_jsxs(Flex, { style: { rowGap: 16 }, children: [_jsx(TextInput, { label: "Label", path: "key", required: true, disablePaste: true }, void 0), _jsx(Select, { label: "Operator", path: "operator", options: [
                    { label: 'equals any of', value: 'In' },
                    { label: 'does not equal any of', value: 'NotIn' },
                    { label: 'exists', value: 'Exists' },
                    { label: 'does not exist', value: 'DoesNotExist' },
                ], required: true }, void 0), _jsx(FlexItem, { children: _jsx(StringsInput, { label: "Values", path: "values", hidden: (labelSelector) => !['In', 'NotIn'].includes(labelSelector.operator), placeholder: "Add value", required: true }, void 0) }, void 0)] }, void 0));
}
export function MatchExpressionCollapsed() {
    const expression = useItem();
    return _jsx(MatchExpressionSummary, { expression: expression }, void 0);
}
export function MatchExpressionSummary(props) {
    const { expression } = props;
    let operator = 'unknown';
    switch (expression.operator) {
        case 'In':
            if (expression.values && expression.values.length > 1) {
                operator = 'equals any of';
            }
            else {
                operator = 'equals';
            }
            break;
        case 'NotIn':
            if (expression.values && expression.values.length > 1) {
                operator = 'does not equal any of';
            }
            else {
                operator = 'does not equal';
            }
            break;
        case 'Exists':
            operator = 'exists';
            break;
        case 'DoesNotExist':
            operator = 'does not exist';
            break;
    }
    const displayMode = useDisplayMode();
    if (!expression.key) {
        if (displayMode === DisplayMode.Details)
            return _jsx(Fragment, {}, void 0);
        return _jsx("div", { children: "Expand to enter expression" }, void 0);
    }
    return (_jsxs("div", { children: [expression.key, " ", operator, " ", expression.values?.map((value) => value).join(', ')] }, void 0));
}
//# sourceMappingURL=MatchExpression.js.map
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { SelectOption } from '@patternfly/react-core';
import get from 'get-value';
import { Fragment, useMemo } from 'react';
import { ArrayInput, EditMode, Hidden, ItemSelector, KeyValue, NumberInput } from '../../src';
import { useEditMode } from '../../src/contexts/EditModeContext';
import { useItem } from '../../src/contexts/ItemContext';
import { Multiselect } from '../../src/inputs/Multiselect';
import { PlacementKind, PlacementType } from '../common/resources/IPlacement';
import { PlacementBindingKind } from '../common/resources/IPlacementBinding';
import { Sync } from '../common/Sync';
import { MatchExpression, MatchExpressionCollapsed, MatchExpressionSummary } from './MatchExpression';
export function Placements(props) {
    const editMode = useEditMode();
    const resources = useItem();
    const namespaceClusterSetNames = useMemo(() => {
        if (!resources.find)
            return [];
        const source = resources?.find((resource) => resource.kind === props.bindingKind);
        if (!source)
            return [];
        const namespace = source.metadata?.namespace;
        if (!namespace)
            return [];
        return (props.clusterSetBindings
            ?.filter((clusterSetBinding) => clusterSetBinding.metadata?.namespace === namespace)
            .map((clusterSetBinding) => clusterSetBinding.spec.clusterSet) ?? []);
    }, [props.bindingKind, props.clusterSetBindings, resources]);
    if (!props.showPlacementRules && !props.showPlacementBindings && props.placementCount === 1) {
        return (_jsxs(Fragment, { children: [_jsx(Sync, { kind: PlacementKind, path: "metadata.name", targetKind: PlacementBindingKind, targetPath: "placementRef.name" }, void 0), _jsx(ItemSelector, { selectKey: "kind", selectValue: PlacementKind, children: _jsx(Placement, { namespaceClusterSetNames: namespaceClusterSetNames }, void 0) }, void 0)] }, void 0));
    }
    return (_jsx(ArrayInput, { id: "placements", label: "Placements", helperText: "A placement selects clusters from the cluster sets which have bindings to the resource namespace.", path: null, isSection: true, filter: (resource) => resource.kind === PlacementKind, placeholder: "Add placement", collapsedContent: "metadata.name", collapsedPlaceholder: "Expand to enter placement", newValue: { ...PlacementType, metadata: { name: '', namespace: '' }, spec: {} }, defaultCollapsed: editMode === EditMode.Edit, children: _jsx(Placement, { namespaceClusterSetNames: namespaceClusterSetNames }, void 0) }, void 0));
}
export function Placement(props) {
    const editMode = useEditMode();
    return (_jsxs(Fragment, { children: [_jsx(Multiselect, { label: "Cluster sets", path: "spec.clusterSets", placeholder: "Select the cluster sets", labelHelp: "Select clusters from the cluster sets bound to the namespace. Cluster can then be further selected using cluster label selectors.", helperText: "If no cluster sets are selected, all clusters will be selected from the cluster sets bound to the namespace.", children: props.namespaceClusterSetNames.map((name) => (_jsx(SelectOption, { value: name }, name))) }, void 0), _jsx(Hidden, { hidden: (placement) => {
                    if (editMode === EditMode.Edit)
                        return true;
                    if (!placement.spec?.predicates)
                        return false;
                    if (placement.spec.predicates.length <= 1)
                        return false;
                    return true;
                }, children: _jsx(PlacementPredicate, { rootPath: "spec.predicates.0." }, void 0) }, void 0), _jsx(ArrayInput, { label: "Cluster selectors", path: "spec.predicates", placeholder: "Add cluster selector", collapsedContent: _jsx(PredicateSummary, {}, void 0), helperText: "\n            A cluster selector further selects clusters from the clusters in the cluster sets which have bindings to the namespace.\n            Clusters matching any cluster selector will be selected.\n            Clusters must match all cluster selector criteria to be selected by that cluster selector.\n            ", defaultCollapsed: true, hidden: (placement) => {
                    if (editMode === EditMode.Edit)
                        return false;
                    if (!placement.spec?.predicates)
                        return true;
                    if (placement.spec.predicates.length <= 1)
                        return true;
                    return false;
                }, children: _jsx(PlacementPredicate, {}, void 0) }, void 0), _jsx(NumberInput, { label: "Limit the number of clusters selected", path: "spec.numberOfClusters", zeroIsUndefined: true, hidden: (placement) => placement.spec?.numberOfClusters === undefined }, void 0)] }, void 0));
}
export function PlacementPredicate(props) {
    const rootPath = props.rootPath ?? '';
    const editMode = useEditMode();
    return (_jsxs(Fragment, { children: [_jsx(KeyValue, { label: "Cluster label selectors", path: `${rootPath}requiredClusterSelector.labelSelector.matchLabels`, labelHelp: "Select clusters from the clusters in selected cluster sets using cluster labels. For a cluster to be be selected, the cluster must match all label selectors, label expressions, and claim expressions.", placeholder: "Add cluster label selector", hidden: (item) => get(item, `${rootPath}requiredClusterSelector.labelSelector.matchLabels`) === undefined }, void 0), _jsx(ArrayInput, { label: "Cluster label expressions", path: `${rootPath}requiredClusterSelector.labelSelector.matchExpressions`, placeholder: "Add label expression", labelHelp: "Select clusters from the clusters in selected cluster sets using cluster labels. For a cluster to be be selected, the cluster must match all label selectors, label expressions, and claim expressions.", collapsedContent: _jsx(MatchExpressionCollapsed, {}, void 0), newValue: { key: '', operator: 'In', values: [''] }, defaultCollapsed: editMode !== EditMode.Create, children: _jsx(MatchExpression, {}, void 0) }, void 0), _jsx(ArrayInput, { label: "Cluster claim expressions", path: `${rootPath}requiredClusterSelector.claimSelector.matchExpressions`, placeholder: "Add claim expression", labelHelp: "Select clusters from the clusters in selected cluster sets using cluster claims status. For a cluster to be be selected, the cluster must match all label selectors, label expressions, and claim expressions.", collapsedContent: _jsx(MatchExpressionCollapsed, {}, void 0), newValue: { key: '', operator: 'In', values: [''] }, defaultCollapsed: editMode !== EditMode.Create, hidden: (item) => get(item, `${rootPath}requiredClusterSelector.claimSelector.matchExpressions`) === undefined, children: _jsx(MatchExpression, {}, void 0) }, void 0)] }, void 0));
}
export function PredicateSummary() {
    const predicate = useItem();
    const labelSelectorLabels = predicate.requiredClusterSelector?.labelSelector?.matchLabels ?? {};
    const labelSelectorExpressions = predicate.requiredClusterSelector?.labelSelector?.matchExpressions ?? [];
    const claimSelectorExpressions = predicate.requiredClusterSelector?.claimSelector?.matchExpressions ?? [];
    const labelSelectors = [];
    for (const matchLabel in labelSelectorLabels) {
        labelSelectors.push(`${matchLabel}=${labelSelectorLabels[matchLabel]}`);
    }
    if (labelSelectors.length === 0 && labelSelectorExpressions.length === 0 && claimSelectorExpressions.length === 0) {
        return _jsx("div", { children: "Expand to enter details" }, void 0);
    }
    return (_jsxs("div", { style: { display: 'flex', gap: 16, flexDirection: 'column' }, children: [labelSelectors.length > 0 && (_jsxs("div", { style: { display: 'flex', gap: 4, flexDirection: 'column' }, children: [_jsx("div", { className: "pf-c-form__label pf-c-form__label-text", children: "Cluster label selectors" }, void 0), _jsx("div", { style: { display: 'flex', flexDirection: 'column', gap: 4 }, children: labelSelectors.map((labelSelector) => (_jsx("span", { children: labelSelector }, labelSelector))) }, void 0)] }, void 0)), labelSelectorExpressions.length > 0 && (_jsxs("div", { style: { display: 'flex', gap: 4, flexDirection: 'column' }, children: [_jsx("div", { className: "pf-c-form__label pf-c-form__label-text", children: "Cluster label expressions" }, void 0), _jsx("div", { style: { display: 'flex', flexDirection: 'column', gap: 4 }, children: labelSelectorExpressions.map((expression, index) => (_jsx(MatchExpressionSummary, { expression: expression }, index))) }, void 0)] }, void 0)), claimSelectorExpressions.length > 0 && (_jsxs("div", { style: { display: 'flex', gap: 4, flexDirection: 'column' }, children: [_jsx("div", { className: "pf-c-form__label pf-c-form__label-text", children: "Cluster claim expressions" }, void 0), _jsx("div", { style: { display: 'flex', flexDirection: 'column', gap: 4 }, children: claimSelectorExpressions.map((expression, index) => (_jsx(MatchExpressionSummary, { expression: expression }, index))) }, void 0)] }, void 0))] }, void 0));
}
//# sourceMappingURL=Placement.js.map
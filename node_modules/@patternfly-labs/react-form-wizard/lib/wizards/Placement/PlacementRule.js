import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import get from 'get-value';
import { Fragment } from 'react';
import { ArrayInput, EditMode, ItemSelector, KeyValue } from '../../src';
import { useEditMode } from '../../src/contexts/EditModeContext';
import { PlacementBindingKind } from '../common/resources/IPlacementBinding';
import { PlacementRuleKind, PlacementRuleType } from '../common/resources/IPlacementRule';
import { Sync } from '../common/Sync';
import { MatchExpression, MatchExpressionCollapsed } from './MatchExpression';
export function PlacementRules(props) {
    const editMode = useEditMode();
    if (!props.showPlacements && !props.showPlacementBindings && props.placementRuleCount === 1) {
        return (_jsxs(Fragment, { children: [_jsx(Sync, { kind: PlacementRuleKind, path: "metadata.name", targetKind: PlacementBindingKind }, void 0), _jsx(Sync, { kind: PlacementRuleKind, path: "metadata.namespace", targetKind: PlacementBindingKind }, void 0), _jsx(Sync, { kind: PlacementRuleKind, path: "metadata.name", targetKind: PlacementBindingKind, targetPath: "placementRef.name" }, void 0), _jsx(ItemSelector, { selectKey: "kind", selectValue: PlacementRuleKind, children: _jsx(PlacementRule, {}, void 0) }, void 0)] }, void 0));
    }
    return (_jsx(ArrayInput, { id: "placement-rules", label: "Placement rules", labelHelp: "Placement rules determine which clusters a resources will be applied.", path: null, isSection: true, filter: (resource) => resource.kind === PlacementRuleKind, placeholder: "Add placement rule", collapsedContent: "metadata.name", collapsedPlaceholder: "Expand to enter placement rule", newValue: {
            ...PlacementRuleType,
            metadata: {},
            spec: { clusterConditions: { status: 'True', type: 'ManagedClusterConditionAvailable' } },
        }, defaultCollapsed: editMode !== EditMode.Create, children: _jsx(PlacementRule, {}, void 0) }, void 0));
}
function PlacementRule() {
    const editMode = useEditMode();
    return (_jsxs(Fragment, { children: [_jsx(KeyValue, { label: "Cluster label selector", path: `spec.clusterSelector.matchLabels`, labelHelp: "A cluster label selector allows simple selection of clusters using cluster labels.", placeholder: "Add cluster label selector", hidden: (item) => get(item, `spec.clusterSelector.matchLabels`) === undefined }, void 0), _jsx(ArrayInput, { id: "label-expressions", label: "Cluster label expression", path: "spec.clusterSelector.matchExpressions", placeholder: "Add cluster label expression", collapsedContent: _jsx(MatchExpressionCollapsed, {}, void 0), newValue: { key: '', operator: 'In', values: [''] }, defaultCollapsed: editMode !== EditMode.Create, children: _jsx(MatchExpression, {}, void 0) }, void 0)] }, void 0));
}
//# sourceMappingURL=PlacementRule.js.map
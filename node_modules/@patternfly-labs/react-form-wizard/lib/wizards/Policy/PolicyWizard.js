import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Button, Text, Title } from '@patternfly/react-core';
import get from 'get-value';
import { Fragment, useContext } from 'react';
import set from 'set-value';
import { ArrayInput, Checkbox, EditMode, Hidden, ItemSelector, Radio, RadioGroup, Section, Select, Step, StringsInput, StringsMapInput, TextInput, WizardPage, } from '../../src';
import { ItemContext } from '../../src/contexts/ItemContext';
import { PlacementBindingKind } from '../common/resources/IPlacementBinding';
import { PlacementRuleKind } from '../common/resources/IPlacementRule';
import { PolicyApiGroup, PolicyKind, PolicyType } from '../common/resources/IPolicy';
import { Sync } from '../common/Sync';
import { isValidKubernetesName } from '../common/validation';
import { PlacementSection } from '../Placement/PlacementSection';
import { Specifications } from './templates';
export function PolicyWizard(props) {
    return (_jsxs(WizardPage, { title: props.title, description: "A policy generates reports and validates cluster compliance based on specified security standards, categories, and controls.", onSubmit: props.onSubmit, onCancel: props.onCancel, editMode: props.editMode, defaultData: props.resources ?? [
            {
                ...PolicyType,
                metadata: { name: '', namespace: '' },
                spec: { remediationAction: 'inform', disabled: false },
            },
        ], children: [_jsxs(Step, { label: "Details", id: "details", children: [props.editMode !== EditMode.Edit && (_jsxs(Fragment, { children: [_jsx(Sync, { kind: PolicyKind, path: "metadata.namespace" }, void 0), _jsx(Sync, { kind: PolicyKind, path: "metadata.name", prefix: "-placement" }, void 0), _jsx(Sync, { kind: PolicyKind, path: "metadata.name", targetKind: PlacementBindingKind, targetPath: "subjects.0.name" }, void 0)] }, void 0)), _jsx(Sync, { kind: PolicyKind, path: "metadata.namespace" }, void 0), _jsx(ItemSelector, { selectKey: "kind", selectValue: PolicyKind, children: _jsxs(Section, { label: "Details", prompt: "Enter the details for the policy", children: [_jsx(TextInput, { id: "name", path: "metadata.name", label: "Name", required: true, validation: isValidKubernetesName, disabledInEditMode: true }, void 0), _jsx(Select, { id: "namespace", path: "metadata.namespace", label: "Namespace", placeholder: "Select namespace", helperText: "The namespace on the hub cluster where the policy resources will be created.", options: props.namespaces, required: true, footer: _jsx(Button, { variant: "link", isInline: true, children: "Create new namespace" }, void 0), disabledInEditMode: true }, void 0), _jsxs(RadioGroup, { path: "spec.remediationAction", label: "Remediation", required: true, children: [_jsx(Radio, { id: "inform", label: "Inform", value: "inform", description: "Reports the violation, which requires manual remediation." }, void 0), _jsx(Radio, { id: "enforce", label: "Enforce", value: "enforce", description: "Automatically runs remediation action that is defined in the source, if this feature is supported." }, void 0)] }, void 0), _jsx(Checkbox, { path: "spec.disabled", label: "Disable policy", helperText: "Select to disable the policy from being propagated to managed clusters." }, void 0)] }, void 0) }, void 0)] }, void 0), _jsx(Step, { label: "Policy templates", id: "templates", children: _jsx(ItemSelector, { selectKey: "kind", selectValue: PolicyKind, children: _jsx(PolicyWizardTemplates, {}, void 0) }, void 0) }, void 0), _jsx(Step, { label: "Cluster placement", id: "placement", children: _jsx(PlacementSection, { existingPlacements: props.placements, existingPlacementRules: props.placementRules, existingclusterSetBindings: props.clusterSetBindings, bindingSubjectKind: PolicyKind, bindingSubjectApiGroup: PolicyApiGroup, defaultPlacementKind: PlacementRuleKind }, void 0) }, void 0), _jsx(Step, { label: "Security groups", id: "security-groups", children: _jsx(ItemSelector, { selectKey: "kind", selectValue: PolicyKind, children: _jsxs(Section, { label: "Security groups", children: [_jsx(StringsMapInput, { id: "categories", path: `metadata.annotations.policy\\.open-cluster-management\\.io/categories`, label: "Categories", map: (value) => {
                                    return value !== undefined ? value.split(',').map((v) => v.trim()) : [];
                                }, unmap: (values) => values.join(', ') }, void 0), _jsx(StringsMapInput, { id: "standards", path: `metadata.annotations.policy\\.open-cluster-management\\.io/standards`, label: "Standards", map: (value) => {
                                    return value !== undefined ? value.split(',').map((v) => v.trim()) : [];
                                }, unmap: (values) => values.join(', ') }, void 0), _jsx(StringsMapInput, { id: "controls", path: `metadata.annotations.policy\\.open-cluster-management\\.io/controls`, label: "Controls", map: (value) => {
                                    return value !== undefined ? value.split(',').map((v) => v.trim()) : [];
                                }, unmap: (values) => values.join(', ') }, void 0)] }, void 0) }, void 0) }, void 0)] }, void 0));
}
export function PolicyWizardTemplates() {
    const policy = useContext(ItemContext);
    return (_jsx(Section, { label: "Templates", description: "A policy contains  policy templates that create policies on managed clusters.", children: _jsxs(ArrayInput, { id: "templates", path: "spec.policy-templates", label: "Policy templates", placeholder: "Add policy template", required: true, dropdownItems: Specifications.map((specification) => {
                return {
                    label: specification.description,
                    action: () => {
                        for (const group of ['categories', 'standards', 'controls']) {
                            const existingValue = get(policy, `metadata.annotations.policy\\.open-cluster-management\\.io/${group}`, '');
                            const addValue = get(specification, `replacements.${group}`, '');
                            const newValue = existingValue
                                .split(',')
                                .concat(addValue.split(','))
                                .map((v) => v.trim())
                                .filter((value, index, array) => array.indexOf(value) === index)
                                .filter((value) => value)
                                .join(', ');
                            set(policy, `metadata.annotations.policy\\.open-cluster-management\\.io/${group}`, newValue, {
                                preservePaths: false,
                            });
                        }
                        const copy = JSON.parse(JSON.stringify(specification.replacements.policyTemplates));
                        const policyName = get(policy, 'metadata.name');
                        if (policyName) {
                            copy.forEach((t) => {
                                const name = get(t, 'objectDefinition.metadata.name');
                                if (name) {
                                    set(t, 'objectDefinition.metadata.name', name.replace('{{name}}', policyName));
                                }
                            });
                        }
                        return copy;
                    },
                };
            }), collapsedContent: "objectDefinition.metadata.name", defaultCollapsed: true, children: [_jsxs(Hidden, { hidden: (template) => template?.objectDefinition?.kind !== 'CertificatePolicy', children: [_jsx("div", { children: _jsx(Title, { headingLevel: "h6", children: "Certificate Policy" }, void 0) }, void 0), _jsx(TextInput, { path: "objectDefinition.metadata.name", label: "Name", required: true, helperText: "Name needs to be unique to the namespace on each of the managed clusters." }, void 0), _jsx(TextInput, { path: "objectDefinition.spec.minimumDuration", label: "Minimum duration", required: true }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (template) => template?.objectDefinition?.kind !== 'IamPolicy', children: [_jsx("div", { children: _jsx(Title, { headingLevel: "h6", children: "IAM Policy" }, void 0) }, void 0), _jsx(TextInput, { path: "objectDefinition.metadata.name", label: "Name", required: true, helperText: "Name needs to be unique to the namespace on each of the managed clusters." }, void 0), _jsx(TextInput, { path: "objectDefinition.spec.maxClusterRoleBindingUsers", label: "Limit cluster role bindings", required: true }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (template) => template?.objectDefinition?.kind !== 'ConfigurationPolicy', children: [_jsxs("div", { children: [_jsx(Title, { headingLevel: "h6", children: "Configuration Policy" }, void 0), _jsx(Text, { component: "small", children: "A configuration policy creates configuration objects on managed clusters." }, void 0)] }, void 0), _jsx(TextInput, { path: "objectDefinition.metadata.name", label: "Name", required: true, helperText: "Name needs to be unique to the namespace on each of the managed clusters." }, void 0), _jsxs(ArrayInput, { path: "objectDefinition.spec.object-templates", label: "Configuration objects", placeholder: "Add configuration object", collapsedContent: "objectDefinition.metadata.name", children: [_jsx(Hidden, { hidden: (template) => template?.objectDefinition?.kind !== 'Namespace', children: _jsx(TextInput, { path: "objectDefinition.metadata.name", label: "Namespace", required: true }, void 0) }, void 0), _jsxs(Hidden, { hidden: (template) => template?.objectDefinition?.kind !== 'LimitRange', children: [_jsx(TextInput, { path: "objectDefinition.metadata.name", label: "Name", required: true, helperText: "Name needs to be unique to the namespace on each of the managed clusters." }, void 0), _jsxs(ArrayInput, { path: "objectDefinition.spec.limits", label: "Limits", placeholder: "Add limit", collapsedContent: 'default.memory', children: [_jsx(TextInput, { path: "default.memory", label: "Memory limit", placeholder: "Enter memory limit", required: true, helperText: "Examples: 512Mi, 2Gi" }, void 0), _jsx(TextInput, { path: "defaultRequest.memory", label: "Memory request", placeholder: "Enter memory request", required: true, helperText: "Examples: 512Mi, 2Gi" }, void 0)] }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (template) => template?.objectDefinition?.kind !== 'SecurityContextConstraints', children: [_jsx(TextInput, { path: "objectDefinition.metadata.name", label: "Name", required: true, helperText: "Name needs to be unique to the namespace on each of the managed clusters." }, void 0), _jsx(Checkbox, { path: "objectDefinition.allowHostDirVolumePlugin", label: "Allow host dir volume plugin" }, void 0), _jsx(Checkbox, { path: "objectDefinition.allowHostIPC", label: "Allow host IPC" }, void 0), _jsx(Checkbox, { path: "objectDefinition.allowHostNetwork", label: "Allow host network" }, void 0), _jsx(Checkbox, { path: "objectDefinition.allowHostPID", label: "Allow host PID" }, void 0), _jsx(Checkbox, { path: "objectDefinition.allowHostPorts", label: "Allow host ports" }, void 0), _jsx(Checkbox, { path: "objectDefinition.allowPrivilegeEscalation", label: "Allow privilege escalation" }, void 0), _jsx(Checkbox, { path: "objectDefinition.allowPrivilegedContainer", label: "Allow privileged container" }, void 0)] }, void 0)] }, void 0)] }, void 0), _jsxs(Hidden, { hidden: (template) => template.objectDefinition.spec.namespaceSelector === undefined, children: [_jsx(StringsInput, { id: "include-namespaces", path: "objectDefinition.spec.namespaceSelector.include", label: "Include namespaces", placeholder: "Add namespace" }, void 0), _jsx(StringsInput, { id: "exclude-namespaces", path: "objectDefinition.spec.namespaceSelector.exclude", label: "Exclude namespaces", placeholder: "Add namespace" }, void 0)] }, void 0), _jsx(Select, { path: "objectDefinition.spec.severity", label: "Severity", placeholder: "Select severity", options: ['low', 'medium', 'high'], required: true }, void 0)] }, void 0) }, void 0));
}
//# sourceMappingURL=PolicyWizard.js.map